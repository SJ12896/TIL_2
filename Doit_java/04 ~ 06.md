## 04. 스택과 큐

### 04-1. 스택

- 스택: 데이터를 일시적으로 저장하기 위한 자료구조. 가장 나중에 넣은 데이터를 가장 먼저 꺼낸다.(후입선출)
  - 푸시: 스택에 데이터를 넣는 작업
  - 팝: 스택에서 데이터를 꺼내는 작업
  - 꼭대기(top): 푸시와 팝을 하는 위치
  - 바닥(bottom): 스태그이 가장 아랫부분
  - 피크(peek): 스택의 꼭대기에 있는 데이터를 몰래 엿보기
  - indexOf: 검색. 같은 요소가 두 개 들어있다면 꼭대기 쪽의 인덱스를 반환한다. 먼저 팝이 되는 데이터를 찾기 위해서
  - clear: 스택의 모든 요소를 삭제
  - capacity: 용량을 확인. max 값을 반환
  - size: 데이터 수를 확인. 현재 스택에 쌓인 데이터 수 반환
  - isEmpty: 스택이 비어있는지 검사
  - isFull: 스택이 가득 찼는지 검사
  - dump: 스택 안에 있는 모든 데이터를 표시. 바닥에서 꼭대기 순으로 표시

### 04-2. 큐

- 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출
- 인큐: 큐에 데이터 넣기
- 디큐: 데이터 꺼내기
- 프런트(front): 데이터를 꺼내는 쪽
- 리어(rear): 데이터를 넣는 쪽
- 링 버퍼: 배열 요소를 앞쪽으로 옮기지 않는 큐. 배열과 처음이 끝과 연결되어 있기 떄문에 논리적으로 첫 요소와 마지막 요소를 식별하기 위해 프런트와 리어를 본다.
- max: 큐의 최대 용량 저장
- num: 현재 데이터 수, front와 rear 값이 같은 경우 큐가 비어있는지 가득 찼는지 구별할 수 있도록 필요

<br>

## 05. 재귀 알고리즘

### 05-1. 재귀의 기본

- 재귀: 어떤 사건이 자기 자신을 포함하고 다시 자기 자신을 사용해 정의될 때
- 유클리드 호제법: 두 정수의 최대 공약수 재귀적으로 구하기. 두 정수를 직사각형의 두 변의 길이라고 생각한다. 직사각형을 정사각형으로 채워 만들 수 있는 정사각형의 가장 긴 변의 길이를 구한다. 처음 시작은 짧은 변의 길이를 한 변으로 하는 정사각형으로 채우고 남의 직사각형에 대해 반복한다.
  - 두 정수 x, y의 최대공약수를 gcd(x, y)라고 표기한다.
  - x = az, y = bz를 만족하는 정수 a, b와 최대의 정수 z가 존재할 때 z = gcd(x, y)라고 할 수 있다.
  - 최대공약수는 y가 0이면 x이고, y가 0이 아니면 gcd(y, x % y)로 구한다.



### 05-2. 재귀 알고리즘 분석

- 재귀 호출을 여러 회 실행하는 메서드를 순수하게 재귀적이라고 한다.

```java
public class Recur {
    static void recur(int n) {
        if (n > 0) {
            recur(n - 1);
            System.out.println(n);
            recur(n-2);
        }
    }
    
    // recur(n-2)를 제거하는 방법
    static void recur2(int n) {
        while (n > 0) {
            recur(n-1);
            System.out.println(n);
            n = n - 2;
        }
    }
    
    // 스택 사용하는 방법
    static void recur3(int n) {
        IntStack s = new IntStack(n);
        
        while (true) {
            if (n > 0) {
                s.push(n);
                n -= 1;
                continue;
            }
            if (s.isEmpty() != true) {
                n = s.pop();
                System.out.println(n);
                n -= 2;
                continue;
            }
            break;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("정수를 입력하세요: ");
        int x = sc.nextInt();

        recur(x);
    }
}
```

- 하향식 분석을 실행할 시 같은 메서드의 호출이 여러 번 나올 수 있어 반드시 효율적이라고 할 수 없다.



### 05-3. 하노이의 탑

- 원반 옮기는 순서: 가장 큰 원반을 최소 단계로 목표 기둥으로 옮기려면 가장 먼저 `그룹`을 중간 기둥으로 옮겨야 한다. 

```java
// 기둥번호 1, 2, 3으로 기둥 번호 합은 6
// 시작 기둥, 목표 기둥이 어느 기둥이더라도 중간 기둥은 6 - x - y
// 바닥 원반 제외하고 그룹을 시작 -> 중간으로
// 바닥을 시작 -> 목표로
// 바닥 원반 제외한 그룹을 중간 -> 목표로

public class Hanoi {
    static void move(int no, int x, int y) {
        if (no > 1)
            move(no -1, x, 6 - x - y);

        System.out.println("원반[" + no + "] 을" + x + "기둥에서 " + y + "기둥으로 옮김");

        if (no > 1)
            move (no - 1, 6 - x - y, y);

    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("하노이의 탑");
        System.out.println("원반 개수: ");
        int n = sc.nextInt();

        move(n, 1, 3);
    }
}
```



## 06. 정렬

### 06-1. 정렬

- 안정된 정렬: 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것.
- 내부 정렬: 하나의 배열에서 작업 가능
- 외부 정렬: 정렬할 데이터가 많아 하나의 배열에서 작업할 수 없음
- 정렬 알고리즘의 핵심 요소: 교환, 선택, 삽입



### 06-2. 버블 정렬

- 이웃한 두 요소의 대소 관계를 비교해 교환을 반복. 요소의 개수가 n개인 배열에서 n-1회를 비교, 교환하고 나면 가장 작은 요소가 맨 처음으로 이동한다. 두 번째 자리를 찾기 위해서는 n-2회를 비교한다. 자리를 찾는 일련의 과정을 패스라고 하는데 모든 정렬이 끝나면 마지막 요소는 이미 끝에 있기 때문에 n-1회의 패스를 수행해야 한다.



### 06-3. 단순 선택 정렬

- 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 정렬하는 알고리즘. 아직 정렬하지 않은 부분의 첫 번째 요소와 교환한다.



### 06-4. 단순 삽입 정렬

- 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복해 정렬하는 알고리즘. 단순 선택 정렬은 값이 가장 작은 요소를 택해 알맞은 위치로 옮긴다는 점이 다르다. 

- Java에서는 '배열의 요소를 알맞은 위치에 삽입합니다'라는 명령이 없다. 따라서 선택한 요소를 왼쪽에 이웃한 요소와 비교해 크면 대입하고 앞으로 이동하면서 반복한다. 그러다가 선택한 값 이하의 요소를 만나면 그 앞쪽은 검사할 필요가 없어 해당 위치에 삽입할 값을 대입한다.



- 단순 정렬(버블, 선택, 삽입)의 시간복잡도는 모두 O(n₂)



### 06-5. 셸 정렬

- 단순 삽입 정렬의 장점은 살리고 단점은 보완
- 단순 삽입 정렬은 정렬을 마친 상태에 가까우면 빨라지지만 삽입할 위치가 멀 때 이동횟수가 많아진다.
- 셸 정렬: 정렬할 배열 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고 그룹을 합치면서 정렬을 반복해 요소 이동 횟수를 줄인다.
- 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬(4-정렬)후 2만큼 떨어진 요소 4개씩 두 그룹을 2-정렬한다. 마지막으로 1-정렬한다.
- 단순삽입 정렬과 비슷하지만 비교 요소가 서로 이웃하지 않고 h만큼 떨어져있다. h값이 서로 배수가 되지 않아요 요소가 충분히 섞여 효율적인 정렬을 기대할 수 있다. 많이 사용하는 방법은 1부터 시작해 * 3 + 1씩 커지게 한다. 또 h초깃값이 너무 크면 효과가 없어 배열 요솟수를 9로 나눈값을 넘지 않도록 정해야 한다.



### 06-6. 퀵 정렬

- 
