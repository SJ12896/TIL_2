## 01. 기본 알고리즘

### 01-1. 알고리즘이란?

- 여러 문장(프로세스)이 순차적으로 실행되는 구조: 순차적 구조
- () 안에 있는 식의 평가 결과에 따라 프로그램의 실행 흐름을 변경하는 if문: 선택(selection) 구조
- next(): 문자열(스페이스, 줄 바꿈 문자로 구분) / nextLine(): 문자열 1줄
- 연산자는 피연산자의 수에 따라 3종류로 나뉜다.
  - 단항 연산자: 예) a++
  - 2항 연산자: 예) a < b
  - 3항 연산자: a ? b : c / 조건연산자는 자바에서 유일한 3항 연산자이다.

### 01-2. 반복

- for문에서 초기화, 제어식, 업데이트 부분은 생략 가능하나 세미콜론은 생략할 수 없다.

<br>

## 02. 기본 자료구조

### 02-1. 배열

- 같은 자료형의 변수로 이루어진 구성 요소가 모인 것
- 구성 요소가 자동으로 0으로 초기화 되는 규칙이 있다. boolean은 false, 참조형은 공백 또는 null
- 클래스의 필드(인스턴수 변수와 클래스 변수)같은 방식으로 초기화된다. 하지만 지역 변수는 초기화되지 않는다. 
- 배열의 복제: 배열 이름.clone() / 다차원 레벨의 복제는 최상위 1레벨만 수행된다. 그 아래 레벨의 배열은 복제되지 않고 공유된다.
- 접근 제한자: public(모든 접근 허용) / protected(같은 패키지의 객체, 상속 관계의 객체 허용) / default(같은 패키지의 객체 허용) / private(현재의 객체 안에서만 허용)
  - 클래스: public, default
  - 생성자, 멤버 변수, 멤버 메서드: public, protected, default, private
  - 지역 변수: 접근 제한자 사용 불가
- 난수 생성: Random클래스 사용. 난수는 무에서 생성되는 것이 아니라 seed라는 수의 값을 바탕으로 여러 연산을 수행해 얻는다. 

```java
// 난수 생성기를 새로 만든다. Random 클래스의 다른 인스턴스와 겹치지 않도록 seed 값을 자동으로 결정한다. 
Random rand = new Random();
// 뚜렷하게 seed를 주는 방법. 주어진 seed를 바탕으로 난수 생성기가 난수를 생성한다.
Random rand = new Random(n);
...
// nextInt(n)이 반환하는 것은 0 ~ n-1까지의 난수
height[i] = 100 + rand.nextInt(90);
```

- String 클래스: java.lang 패키지의 String 클래스를 통해 문자열을 나타낸다. int나 double같은 기본형이 아니다. 문자열 리터럴은 단순히 문자가 늘어선 것이 아니라 String형 인스턴스에 대한 참조다. 
  - char charAt(int i): 인덱스가 i인 곳의 문자 가져오기
  - int length(): 문자열의 문자 수 가져오기
  - boolean equals(String s): 문자열 s와 같은가를 조사하기

- 소수: n의 제곱근 이하의 어떤 소수로도 나누어 떨어지지 않는다.
- 다차원 배열: 배열을 구성 요소로 하는 것이 2차원 배열, 2차원 배열을 구성 요소로 하는 것이 3차원 배열. 사실 java는 엄밀한 의미에선 다차원 배열이 없다. 2차원 배열은 **배열의 배열**로 생각하고 3차원배열은 **배열의 배열의 배열**로 생각하기 때문이다.
- 클래스를 간단한 이름으로 사용하기 위해 그 형의 이름을 명시적으로 형 import를 선언할 필요가 있지만 java 언어와 밀접하게 연관된 클래스, 인터페이스를 모아둔 java.lang 패키지는 형 import를 선언할 필요 없다. 따라서 Integer, String 등의 클래스는 간단한 이름만으로 나타낼 수 있다.
- 확장 for문: 배열의 길이를 조사하는 수고를 줄일 수 있고 iterator와 같은 방법으로 스캔할 수 있다.

```java
// :는 ~의 안에 있는이라는 뜻.(in)
// 확장 for문을 for-in문 또는 for-each문이라고 한다.
// i는 int형 정수인 인덱스가 아니라 double형 실수의 값인 스캔할 때 주목하고 있는 요소
for (double i : a)
    sum += i;
```



<br>

## 03. 검색

### 03-3. 이진 검색

- 전제 조건: 데이터가 키 값으로 이미 정렬되어 있다. (오름차순 또는 내림차순)
- 한 단계씩 진행할 때마다 검색 범위가 거의 반으로 좁혀진다. 검색에 필요한 비교 횟수의 평균값은 **log n**
- 복잡도: 알고리즘 성능을 객관적으로 평가하는 기준
  - 시간 복잡도: 실행에 필요한 시간을 평가한 것
  - 공간 복잡도: 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
  - 한 번만 실행: O(1)
  - 배열에 맨 끝에 도달했는지 또는 현재 검사하는 요소와 찾는 값이 같은지 판단할 때의 평균 실행 횟수는 n/2: O(n) / n이 무한히 커진다고 가정하면 n/2와 n의 차이가 무의미해지기 때문에 n/2가 아닌 n의 복잡도를 가졌다고 표현한다.
  - O(f(n))과 O(g(n))의 복잡도를 계산하는 방법: O(f(n)) + O(g(n)) = O(max(f(n), g(n))) / 2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시한다.
- java는 배열에서 이진 검색을 하는 메서드를 표준 라이브러리로 제공한다. java.utils.Arrays 클래스의 binarySearch 메서드. 자료형에 따라 9가지 방법으로 오버로딩(같은 메서드 이름으로 매개변수만 다르게 정의) 되어있다. 
  - 검색에 성공하면 key와 일치하는 요소의 인덱스를 반환한다. 여러 개가 일치하면 무작위로 반환한다.
  - 검색에 실패하면 삽입 포인트가 x일 때 -x-1을 반환한다. 삽입 포인트는 검색하기 위해 지정한 key보다 큰 요소 중 첫 번째 요소의 인덱스다.
  - int나 long같은 기본 자료형 배열에서 이진 검색을 하는 메서드