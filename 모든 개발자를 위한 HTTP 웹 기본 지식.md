# 모든 개발자를 위한 HTTP 웹 기본 지식

- 앱 - 서버, 서버 - 서버가 통신할 때도 http 프로토콜 위에서 정보를 주고 받는다. 

<br>

## 인터넷 네트워크

### 인터넷 통신

- 웹, http도 모두 인터넷 망위에서 동작하기 때문에 사전 학습
- 클라이언트, 서버가 서로 멀리 있어 인터넷 망을 통해 전달되어야 하는데 어떻게 목적지까지 도착하는지 알기위해 ip(인터넷 프로토콜)를 알아야 한다.

### IP(인터넷 프로토콜)

- 클라이언트가 ip주소를 부여받고 메세지를 받는 서버도 ip주소가 있다. 
- ip는 지정한 ip주소에 패킷이라는 통신 단위로 데이터를 전달한다.
- ip 패킷은 전송 데이터에 출발지 ip, 목적지 ip가 필요하다. 
  - package + bucket?
- 클라이언트가 ip 패킷을 인터넷 망에서 던져 노드들이 서로 보내며 최종 목적지인 서버에 도달한다. 서버에서 클라이언트로 보낼 때도 마찬가지다. 하지만 요청, 응답 경로를 서로 다를 수 있다.
- 한계
  - 비연결성: 패킷 받을 대상 없거나 서비스 불능이어도 전송. 대상 서버가 패킷을 받을 수 있는 상태인지 모른다.
  - 비신뢰성: 중간에 사라지면? 중간 서버에 문자가 생겨서 내가 보낸 패킷이 사라져도 모른다. 또 순서대로 안오면? 패킷 용량이 클 때(1500바이트 이상 정도) 끊어서 보내는데 중간에 나뉜 패킷들이 서로 다른 경로를 가게 되어 순서가 바뀔 수 있다.
  - 프로그램 구분: 같은 ip사용하는 서버에서 통신 애플리케이션이 둘 이상이면? 게임하면서 음악도 듣고 있을 때

### TCP, UDP

- 인터넷 프로토콜 스택의 4계층

  - 애플리케이션 계층 - HTTP, FTP
  - 전송 계층 - TCP, UDP (IP위에 살짝 올려서 보완)
  - 인터넷 계층 - IP
  - 네트워크 인터페이스 계층

- 프로토콜 계층

  - 애플리케이션
    - 웹 브라우저, 네트워크 게임, 채팅
    - SOCKET 라이브러리
  - OS
    - TCP / UDP
    - IP
  - 네트워크 인터페이스
    - LAN 드라이버
    - LAN 장비
  - 채팅으로 메세지를 전송하면 SOCKET라이브러리를 통해 OS계층에 메세지를 넘기면 TCP가 메세지에 TCP정보를 씌운다. 그리고 그 위에 IP관련 정보를 씌워 패킷을 만든다. 그리고 LAN카드를 통해 ethernet frame을 포함해 나간다.(MAC주소같은 물리적 정보 포함.

  - TCP: 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보

- TCP(Transmission Control Protocl) 특징: 전송 제어 프로토콜.

  - 연결지향: 연결 후 메세지를 보냄. 상대방 연결 불가능 상태면 안됨. 
    - TCP 3 way handshake: 가상 연결(개념적으로만 연결. 물리적으로 연결된게 아니다. 예전엔 서로 물리적으로 포트를 꽂아 연결했지만 요즘은 그게 아니고 중간에 수많은 서버를 거치고 있다) / TCP/IP프로토콜로 연결하면 클라이언트에서 서버로 SYN(synchronize) 메세지를 보낸다. 서버에서 SYN +ACK(acknowledgment)를 보낸다. 알겠고 나도 연결해주란 뜻. 그러면 다시 클라이언트에서 ACK(알았음)을 보내면 서버가 데이터를 전송해준다. 양 쪽이 서로 SYN을 보내고 ACK를 보내므로 서로를 믿을 수 있는 상태다. 한 쪽이라도 응답이 없으면 데이터를 보내지 않는다. 요즘 최적화가 되어 서버가 ACK를 보내며 데이터도 같이 보낸다. 
  - 데이터 전달 보증: 중간 유실되면 알 수 있음. 클라이언트가 데이터 전송하면 서버가 잘 받았다고 답해줌. 안오면 문제 있는걸 알게됨.
  - 순서 보장: 클라이언트가 패킷을 1, 2, 3 순서로 보냈는데 서버에 1, 3, 2 순서로 도착했다면 서버에서 2번부터 다시 보내라고 한다. 
  - 신뢰할 수 있는 프로토콜이며 대부분의 애플리케이션에서 사용한다.



- UDP(User Datagram Protocol) 특징: 기능이 없어 하얀 도화지 같다. 연결지향, 전달 보증, 순서 보장 모두 없다. 단순하고 빠르며 IP와 비슷한데 위에 `PORT`(게임, 음악등을 동시에 할 때 내 IP로 여러 패킷이 오는데 PORT를 통해 이를 구분한다.), 체크섬(메세지에 대해 제대로 왔는지 검증)이 추가되어있다. TCP는 3 way handshake를 하느라 시간이 걸리고 데이터도 크고 그래서 최적화를 할 수 있는 UDP를 써서 애플리케이션에서 추가 작업을 한다. 최근엔 주목받고 있다.



### PORT

- 한 번에 둘 이상을 연결해야 할 때(게임도 하고 화상 통화, 서핑도 한다면) 클라이언트가 여러 서버랑 통신해야 하는데 패킷이 올 때 어디서 필요한 패킷인지 알 수 없다. 보낼 때도 마찬가지다. ip만으로 해결할 수 없어 TCP, UDP에 있는 출발지와 목적지 PORT를 사용한다. IP는 서버를 찾는거고 그 안의 애플리케이션을 구분(프로세스 구분)하는 것이 PORT다. 
- IP가 아파트면 PORT는 동호수같은 느낌
- 0 ~ 65535는 할당 가능
- 0 ~ 1023: 잘 알려져 사용하지 않는 것이 좋다.
- FTP: 20, 21
- TELNET: 23
- HTTP: 80
- HTTPS: 443



### DNS

- IP는 기억하기 어렵고 변경될 수 있다. 
- 도메인 네임 시스템(Domain Name System)
- DNS 서버에 도메인 명과 IP를 등록하면 도메인으로 찾으면 DNS서버가 IP를 응답하고 그걸 통해 접속한다.



## URI와 웹 브라우저 요청 흐름

### URI

- Uniform Resource Identifier: 리소스 식별, 가장 큰 개념. 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다. / 리소스 식별하는 통일된 방식 / 자원, URI로 식별할 수 있는 모든 것(제한 없음) / 다른 항목과 구분하는데 필요한 정보
  - URL(Resource Locator): 리소스의 위치. 일반적으로 우리가 보던 웹 주소같은거.
  - URN(Resource Name): 리소스의 이름. 정말 이름:이름:이름으로 연결된 주소. 
  - 위치는 변할 수 있지만 이름은 변하지 않는다. 마치 도서 isbn같은 것. 그런데 이름으로 실제 리소스를 찾는 방법이 보편화 되지 않아 거의 URL만 사용된다.
- `scheme://[userinfo@]host[:port][/path][?query][#fragment]`
  - scheme: 주로 프로토콜(어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙) 사용. http(80 포트), https(443 포트, http Secure), ftp 등.
  - userinfo: url에 사용자 정보 포함해 인증. 거의 사용X
  - host: 호스트명, 도메인명이나 ip직접 사용
  - port: 접속 포트, 일반적으로 생략
  - path: 리소스 경로. 계층적 구조
  - query: key=value형태. ?로 시작, &로 추가 가능. 쿼리 파라미터, 쿼리 스트링 등으로 불림
  - fragment: html 내부 북마크 등에 사용. 서버에 전송하는 정보가 아니다. 

### 웹 브라우저 요청 흐름

- url로 요청을 보내면 dns 서버를 조회해 ip결과와 port 번호를 가지고 http 요청 메시지를 생성한다. SOCKET 라이브러리를 통해 OS TCP/IP계층에 전달하는데 먼저 TCP/IP로 IP, PORT 정보를 가지고 서버랑 연결을 한다. 그리고 OS에 데이터를 전달하면 TCP/IP에서 HTTP메세지를 포함한 패킷으로 만들어진 후 서버로 가게 된다. 도착하면 TCP/IP를 다 까서 버리고 HTTP 메세지를 해석해서 데이터를 찾아 HTTP 응답 메세지를 만들고 똑같이 응답 패킷을 만들어 응답한다.



## HTTP 기본

### 모든 것이 HTTP

- HyperText Transfer Protocol: 문서간 링크를 통해 이동할 수 있는 hypertext를 전송하는 protocol
- 현재는 html, text, image, 파일, json등 모든 형태 데이터 전송 가능.
- 서버간 데이터를 주고 받을 때도 사용
- HTTP/1.1: **가장 많이 사용, 우리에게 중요** / RFC2616(1999, 50퍼센트 이상이 이거) 이 다음은 2014년에 나온 RFC 7230 ~ 7235 / 2는 성능 개선, 3는 진행중으로 TCP대신 UDP 사용. 2, 3도 증가하고 있다. 구글 사용
- 기반 프로토콜
  - TCP: HTTP/1.1, HTTP/2
  - UDP: HTTP/3
- 특징: 클라이언트 서버 구조, 무상태 프로토콜(스테이트리스), 비연결성, http 메시지, 단순함, 확장 가능

### 클라이언트 서버 구조

- Request Response 구조: 클라이언트가 서버에 요청 보내고 응답 대기. 서버가 요청에 대한 결과를 만들어 응답. 이렇게 클라이언트와 서버를 분리해야 비지니스 로직, 데이터를 서버에 두고 클라이언트는 사용성, ui에 집중해 각각 발전할 수 있었다.

### Stateful, Stateless

- 무상태 프로토콜. 서버가 클라이언트의 상태를 보존하지 않는다. 
- 장점은 서버 확장성 높음(스케일 아웃 - 수평 확장 유리)
- 단점은 클라이언트가 추가 데이터 전송
- 상태 유지 - Stateful: 가게에서 손님 응대를 하며 중간에 점원이 계속 바뀐다면? 새로온 점원은 앞서 정했던 물건이나 결제 방식을 알 수 없다. 따라서 앞선 상태 유지가 되고 있어야 한다. 
  - 같은 기능을 하는 서버가 여러개 있어도 항상 같은 서버가 유지되어야 한다. 그래서 중간에 갑자기 서버가 죽으면 처음부터 다시 진행해야 한다.
- 무상태 - Stateless: 고객이 계속 앞서 정했던 자신의 상태를 새 요청을 할 때 언급한다. 이럴경우 고객이 증가하면 점원을 대거 투입할 수 있다.
  - 클라이언트 요청이 갑자기 증가해도 서버 대거 투입 가능
  - 응답 서버를 쉽게 바꿀 수 있어 **무한한 서버 증설 가능**
  - 서버 에러가 발생해도 요청 계속 진행 가능
  - 단점은 전송되는 데이터가 많다.

- 그러나 모든 경우에서 사용할 수는 없다. 로그인같은 경우는 상태 유지가 필요하다.(로그인 한 사용자의 상태를 서버에 유지)
- 일반적으로 브라우저 쿠키, 서버 세션을 사용해 유지한다.
- 상태 유지는 최소한만 사용해야 한다.

### 비연결성(connectionless)

- 연결을 유지하면 클라이언트가 각각 한 서버에 요청을 보내면 서버는 연결을 계속 유지하며 서버 자원을 소모한다.
- 연결을 유지하지 않으면 요청에 대한 응답이 오면 바로 연결을 유지하지 않고 서버에서 최소한의 자원을 유지한다.
- HTTP는 기본이 연결을 유지하지 않는 모델. 일반적으로 초 단위 이하의 빠른 속도로 응답하며 서버 자원을 효율적으로 사용한다.
- 1시간 동안 수천명이 서비스를 이용해도 실제 서버에서 동시 처리하는 요청은 수십개 이하로 매우 작다.(모두 동시에 계속 서비스를 요청하는건 아니니까) 
- 비연결성의 한계와 극복: TCP/IP 연결을 새로 맺어야해서 3 way handshake 시간이 추가되고 요청하면서 html, js, css 등 많은 자원이 함께 다운로드 된다.
  - 현재 HTTP 지속 연결(Persistent Connections)로 문제 해결
  - HTTP/2, 3에서 더 많은 최적화
- 초기에 html 응답하고 종료했다가 js필요하면 또 연결해서 받고 종료하고 이런과정을 반복했다. 지속연결을 하면 연결 상태에서 요청-응답을 하며 유지하다가 종료한다.
- `스테이트리스`를 기억해야 한다. 서버 개발자들이 같은 시간에 사람들이 몰리는 업무를 가장 어려워한다. 
- 첫페이지는 정적 페이지만 두고 사람들이 그 안에서 있게 하다가 참여하게 하거나 그렇다.

### HTTP 메시지

- 구조: start-line(시작 라인) - header(헤더) - empty line(공백 라인, CRLF. 무조건 있어야 함) - message body
- start-line = request-line / status-line
  - request-line = method SP(공백), requeset-target, SP, HTTP-version, CRLF(엔터)
  - requeset-target: `absolute-path[?query`](절대경로?[쿼리]), (절대경로는 /로 시작하는 경로)
  - HTTP version
  - status-line = HTTP-version SP status-code SP reason-phrase CRLF
  - status-code: 200성공, 400클라이언트 요청 오류, 500서버 내부 오류
  - reason-phrase: 사람이 이해할 수 있는 짧은 상태코드 설명 글
- header
  - header-field = field-name ":" OWS(띄어쓰기 허용) field-value OWS 
  - field-name 대소문자 구분 없음
  - ex: HOST: www.google.com (host바로 뒤는 띄어쓰기 x : 뒤는 가능)
  - http 전송에 필요한 모든 부가 정보가 들어 있다. 바디 내용, 크기, 압축여부, 인증정보 등
  - 표준 헤더가 매우 많으며 필요시 임의 추가 가능
- 메세지 바디: 실제 전송할 데이터. byte로 표현가능한 모든 데이터 전송 가능
- http 메시지는 단순하지만 확장 가능하다.
