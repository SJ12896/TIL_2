# 모든 개발자를 위한 HTTP 웹 기본 지식

- 앱 - 서버, 서버 - 서버가 통신할 때도 http 프로토콜 위에서 정보를 주고 받는다. 

<br>

## 인터넷 네트워크

### 인터넷 통신

- 웹, http도 모두 인터넷 망위에서 동작하기 때문에 사전 학습
- 클라이언트, 서버가 서로 멀리 있어 인터넷 망을 통해 전달되어야 하는데 어떻게 목적지까지 도착하는지 알기위해 ip(인터넷 프로토콜)를 알아야 한다.

### IP(인터넷 프로토콜)

- 클라이언트가 ip주소를 부여받고 메세지를 받는 서버도 ip주소가 있다. 
- ip는 지정한 ip주소에 패킷이라는 통신 단위로 데이터를 전달한다.
- ip 패킷은 전송 데이터에 출발지 ip, 목적지 ip가 필요하다. 
  - package + bucket?
- 클라이언트가 ip 패킷을 인터넷 망에서 던져 노드들이 서로 보내며 최종 목적지인 서버에 도달한다. 서버에서 클라이언트로 보낼 때도 마찬가지다. 하지만 요청, 응답 경로를 서로 다를 수 있다.
- 한계
  - 비연결성: 패킷 받을 대상 없거나 서비스 불능이어도 전송. 대상 서버가 패킷을 받을 수 있는 상태인지 모른다.
  - 비신뢰성: 중간에 사라지면? 중간 서버에 문자가 생겨서 내가 보낸 패킷이 사라져도 모른다. 또 순서대로 안오면? 패킷 용량이 클 때(1500바이트 이상 정도) 끊어서 보내는데 중간에 나뉜 패킷들이 서로 다른 경로를 가게 되어 순서가 바뀔 수 있다.
  - 프로그램 구분: 같은 ip사용하는 서버에서 통신 애플리케이션이 둘 이상이면? 게임하면서 음악도 듣고 있을 때

### TCP, UDP

- 인터넷 프로토콜 스택의 4계층

  - 애플리케이션 계층 - HTTP, FTP
  - 전송 계층 - TCP, UDP (IP위에 살짝 올려서 보완)
  - 인터넷 계층 - IP
  - 네트워크 인터페이스 계층

- 프로토콜 계층

  - 애플리케이션
    - 웹 브라우저, 네트워크 게임, 채팅
    - SOCKET 라이브러리
  - OS
    - TCP / UDP
    - IP
  - 네트워크 인터페이스
    - LAN 드라이버
    - LAN 장비
  - 채팅으로 메세지를 전송하면 SOCKET라이브러리를 통해 OS계층에 메세지를 넘기면 TCP가 메세지에 TCP정보를 씌운다. 그리고 그 위에 IP관련 정보를 씌워 패킷을 만든다. 그리고 LAN카드를 통해 ethernet frame을 포함해 나간다.(MAC주소같은 물리적 정보 포함.

  - TCP: 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보

- TCP(Transmission Control Protocl) 특징: 전송 제어 프로토콜.

  - 연결지향: 연결 후 메세지를 보냄. 상대방 연결 불가능 상태면 안됨. 
    - TCP 3 way handshake: 가상 연결(개념적으로만 연결. 물리적으로 연결된게 아니다. 예전엔 서로 물리적으로 포트를 꽂아 연결했지만 요즘은 그게 아니고 중간에 수많은 서버를 거치고 있다) / TCP/IP프로토콜로 연결하면 클라이언트에서 서버로 SYN(synchronize) 메세지를 보낸다. 서버에서 SYN +ACK(acknowledgment)를 보낸다. 알겠고 나도 연결해주란 뜻. 그러면 다시 클라이언트에서 ACK(알았음)을 보내면 서버가 데이터를 전송해준다. 양 쪽이 서로 SYN을 보내고 ACK를 보내므로 서로를 믿을 수 있는 상태다. 한 쪽이라도 응답이 없으면 데이터를 보내지 않는다. 요즘 최적화가 되어 서버가 ACK를 보내며 데이터도 같이 보낸다. 
  - 데이터 전달 보증: 중간 유실되면 알 수 있음. 클라이언트가 데이터 전송하면 서버가 잘 받았다고 답해줌. 안오면 문제 있는걸 알게됨.
  - 순서 보장: 클라이언트가 패킷을 1, 2, 3 순서로 보냈는데 서버에 1, 3, 2 순서로 도착했다면 서버에서 2번부터 다시 보내라고 한다. 
  - 신뢰할 수 있는 프로토콜이며 대부분의 애플리케이션에서 사용한다.



- UDP(User Datagram Protocol) 특징: 기능이 없어 하얀 도화지 같다. 연결지향, 전달 보증, 순서 보장 모두 없다. 단순하고 빠르며 IP와 비슷한데 위에 `PORT`(게임, 음악등을 동시에 할 때 내 IP로 여러 패킷이 오는데 PORT를 통해 이를 구분한다.), 체크섬(메세지에 대해 제대로 왔는지 검증)이 추가되어있다. TCP는 3 way handshake를 하느라 시간이 걸리고 데이터도 크고 그래서 최적화를 할 수 있는 UDP를 써서 애플리케이션에서 추가 작업을 한다. 최근엔 주목받고 있다.



### PORT

- 한 번에 둘 이상을 연결해야 할 때(게임도 하고 화상 통화, 서핑도 한다면) 클라이언트가 여러 서버랑 통신해야 하는데 패킷이 올 때 어디서 필요한 패킷인지 알 수 없다. 보낼 때도 마찬가지다. ip만으로 해결할 수 없어 TCP, UDP에 있는 출발지와 목적지 PORT를 사용한다. IP는 서버를 찾는거고 그 안의 애플리케이션을 구분(프로세스 구분)하는 것이 PORT다. 
- IP가 아파트면 PORT는 동호수같은 느낌
- 0 ~ 65535는 할당 가능
- 0 ~ 1023: 잘 알려져 사용하지 않는 것이 좋다.
- FTP: 20, 21
- TELNET: 23
- HTTP: 80
- HTTPS: 443



### DNS

- IP는 기억하기 어렵고 변경될 수 있다. 
- 도메인 네임 시스템(Domain Name System)
- DNS 서버에 도메인 명과 IP를 등록하면 도메인으로 찾으면 DNS서버가 IP를 응답하고 그걸 통해 접속한다.



## URI와 웹 브라우저 요청 흐름

### URI

- Uniform Resource Identifier: 리소스 식별, 가장 큰 개념. 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다. / 리소스 식별하는 통일된 방식 / 자원, URI로 식별할 수 있는 모든 것(제한 없음) / 다른 항목과 구분하는데 필요한 정보
  - URL(Resource Locator): 리소스의 위치. 일반적으로 우리가 보던 웹 주소같은거.
  - URN(Resource Name): 리소스의 이름. 정말 이름:이름:이름으로 연결된 주소. 
  - 위치는 변할 수 있지만 이름은 변하지 않는다. 마치 도서 isbn같은 것. 그런데 이름으로 실제 리소스를 찾는 방법이 보편화 되지 않아 거의 URL만 사용된다.
- `scheme://[userinfo@]host[:port][/path][?query][#fragment]`
  - scheme: 주로 프로토콜(어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙) 사용. http(80 포트), https(443 포트, http Secure), ftp 등.
  - userinfo: url에 사용자 정보 포함해 인증. 거의 사용X
  - host: 호스트명, 도메인명이나 ip직접 사용
  - port: 접속 포트, 일반적으로 생략
  - path: 리소스 경로. 계층적 구조
  - query: key=value형태. ?로 시작, &로 추가 가능. 쿼리 파라미터, 쿼리 스트링 등으로 불림
  - fragment: html 내부 북마크 등에 사용. 서버에 전송하는 정보가 아니다. 

### 웹 브라우저 요청 흐름

- url로 요청을 보내면 dns 서버를 조회해 ip결과와 port 번호를 가지고 http 요청 메시지를 생성한다. SOCKET 라이브러리를 통해 OS TCP/IP계층에 전달하는데 먼저 TCP/IP로 IP, PORT 정보를 가지고 서버랑 연결을 한다. 그리고 OS에 데이터를 전달하면 TCP/IP에서 HTTP메세지를 포함한 패킷으로 만들어진 후 서버로 가게 된다. 도착하면 TCP/IP를 다 까서 버리고 HTTP 메세지를 해석해서 데이터를 찾아 HTTP 응답 메세지를 만들고 똑같이 응답 패킷을 만들어 응답한다.
