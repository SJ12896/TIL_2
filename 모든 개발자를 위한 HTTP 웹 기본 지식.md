# 모든 개발자를 위한 HTTP 웹 기본 지식

- 앱 - 서버, 서버 - 서버가 통신할 때도 http 프로토콜 위에서 정보를 주고 받는다. 

<br>

## 인터넷 네트워크

### 인터넷 통신

- 웹, http도 모두 인터넷 망위에서 동작하기 때문에 사전 학습
- 클라이언트, 서버가 서로 멀리 있어 인터넷 망을 통해 전달되어야 하는데 어떻게 목적지까지 도착하는지 알기위해 ip(인터넷 프로토콜)를 알아야 한다.

### IP(인터넷 프로토콜)

- 클라이언트가 ip주소를 부여받고 메세지를 받는 서버도 ip주소가 있다. 
- ip는 지정한 ip주소에 패킷이라는 통신 단위로 데이터를 전달한다.
- ip 패킷은 전송 데이터에 출발지 ip, 목적지 ip가 필요하다. 
  - package + bucket?
- 클라이언트가 ip 패킷을 인터넷 망에서 던져 노드들이 서로 보내며 최종 목적지인 서버에 도달한다. 서버에서 클라이언트로 보낼 때도 마찬가지다. 하지만 요청, 응답 경로를 서로 다를 수 있다.
- 한계
  - 비연결성: 패킷 받을 대상 없거나 서비스 불능이어도 전송. 대상 서버가 패킷을 받을 수 있는 상태인지 모른다.
  - 비신뢰성: 중간에 사라지면? 중간 서버에 문자가 생겨서 내가 보낸 패킷이 사라져도 모른다. 또 순서대로 안오면? 패킷 용량이 클 때(1500바이트 이상 정도) 끊어서 보내는데 중간에 나뉜 패킷들이 서로 다른 경로를 가게 되어 순서가 바뀔 수 있다.
  - 프로그램 구분: 같은 ip사용하는 서버에서 통신 애플리케이션이 둘 이상이면? 게임하면서 음악도 듣고 있을 때

### TCP, UDP

- 인터넷 프로토콜 스택의 4계층

  - 애플리케이션 계층 - HTTP, FTP
  - 전송 계층 - TCP, UDP (IP위에 살짝 올려서 보완)
  - 인터넷 계층 - IP
  - 네트워크 인터페이스 계층

- 프로토콜 계층

  - 애플리케이션
    - 웹 브라우저, 네트워크 게임, 채팅
    - SOCKET 라이브러리
  - OS
    - TCP / UDP
    - IP
  - 네트워크 인터페이스
    - LAN 드라이버
    - LAN 장비
  - 채팅으로 메세지를 전송하면 SOCKET라이브러리를 통해 OS계층에 메세지를 넘기면 TCP가 메세지에 TCP정보를 씌운다. 그리고 그 위에 IP관련 정보를 씌워 패킷을 만든다. 그리고 LAN카드를 통해 ethernet frame을 포함해 나간다.(MAC주소같은 물리적 정보 포함.

  - TCP: 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보

- TCP(Transmission Control Protocl) 특징: 전송 제어 프로토콜.

  - 연결지향: 연결 후 메세지를 보냄. 상대방 연결 불가능 상태면 안됨. 
    - TCP 3 way handshake: 가상 연결(개념적으로만 연결. 물리적으로 연결된게 아니다. 예전엔 서로 물리적으로 포트를 꽂아 연결했지만 요즘은 그게 아니고 중간에 수많은 서버를 거치고 있다) / TCP/IP프로토콜로 연결하면 클라이언트에서 서버로 SYN(synchronize) 메세지를 보낸다. 서버에서 SYN +ACK(acknowledgment)를 보낸다. 알겠고 나도 연결해주란 뜻. 그러면 다시 클라이언트에서 ACK(알았음)을 보내면 서버가 데이터를 전송해준다. 양 쪽이 서로 SYN을 보내고 ACK를 보내므로 서로를 믿을 수 있는 상태다. 한 쪽이라도 응답이 없으면 데이터를 보내지 않는다. 요즘 최적화가 되어 서버가 ACK를 보내며 데이터도 같이 보낸다. 
  - 데이터 전달 보증: 중간 유실되면 알 수 있음. 클라이언트가 데이터 전송하면 서버가 잘 받았다고 답해줌. 안오면 문제 있는걸 알게됨.
  - 순서 보장: 클라이언트가 패킷을 1, 2, 3 순서로 보냈는데 서버에 1, 3, 2 순서로 도착했다면 서버에서 2번부터 다시 보내라고 한다. 
  - 신뢰할 수 있는 프로토콜이며 대부분의 애플리케이션에서 사용한다.



- UDP(User Datagram Protocol) 특징: 기능이 없어 하얀 도화지 같다. 연결지향, 전달 보증, 순서 보장 모두 없다. 단순하고 빠르며 IP와 비슷한데 위에 `PORT`(게임, 음악등을 동시에 할 때 내 IP로 여러 패킷이 오는데 PORT를 통해 이를 구분한다.), 체크섬(메세지에 대해 제대로 왔는지 검증)이 추가되어있다. TCP는 3 way handshake를 하느라 시간이 걸리고 데이터도 크고 그래서 최적화를 할 수 있는 UDP를 써서 애플리케이션에서 추가 작업을 한다. 최근엔 주목받고 있다.



### PORT

- 한 번에 둘 이상을 연결해야 할 때(게임도 하고 화상 통화, 서핑도 한다면) 클라이언트가 여러 서버랑 통신해야 하는데 패킷이 올 때 어디서 필요한 패킷인지 알 수 없다. 보낼 때도 마찬가지다. ip만으로 해결할 수 없어 TCP, UDP에 있는 출발지와 목적지 PORT를 사용한다. IP는 서버를 찾는거고 그 안의 애플리케이션을 구분(프로세스 구분)하는 것이 PORT다. 
- IP가 아파트면 PORT는 동호수같은 느낌
- 0 ~ 65535는 할당 가능
- 0 ~ 1023: 잘 알려져 사용하지 않는 것이 좋다.
- FTP: 20, 21
- TELNET: 23
- HTTP: 80
- HTTPS: 443



### DNS

- IP는 기억하기 어렵고 변경될 수 있다. 
- 도메인 네임 시스템(Domain Name System)
- DNS 서버에 도메인 명과 IP를 등록하면 도메인으로 찾으면 DNS서버가 IP를 응답하고 그걸 통해 접속한다.



## URI와 웹 브라우저 요청 흐름

### URI

- Uniform Resource Identifier: 리소스 식별, 가장 큰 개념. 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다. / 리소스 식별하는 통일된 방식 / 자원, URI로 식별할 수 있는 모든 것(제한 없음) / 다른 항목과 구분하는데 필요한 정보
  - URL(Resource Locator): 리소스의 위치. 일반적으로 우리가 보던 웹 주소같은거.
  - URN(Resource Name): 리소스의 이름. 정말 이름:이름:이름으로 연결된 주소. 
  - 위치는 변할 수 있지만 이름은 변하지 않는다. 마치 도서 isbn같은 것. 그런데 이름으로 실제 리소스를 찾는 방법이 보편화 되지 않아 거의 URL만 사용된다.
- `scheme://[userinfo@]host[:port][/path][?query][#fragment]`
  - scheme: 주로 프로토콜(어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙) 사용. http(80 포트), https(443 포트, http Secure), ftp 등.
  - userinfo: url에 사용자 정보 포함해 인증. 거의 사용X
  - host: 호스트명, 도메인명이나 ip직접 사용
  - port: 접속 포트, 일반적으로 생략
  - path: 리소스 경로. 계층적 구조
  - query: key=value형태. ?로 시작, &로 추가 가능. 쿼리 파라미터, 쿼리 스트링 등으로 불림
  - fragment: html 내부 북마크 등에 사용. 서버에 전송하는 정보가 아니다. 

### 웹 브라우저 요청 흐름

- url로 요청을 보내면 dns 서버를 조회해 ip결과와 port 번호를 가지고 http 요청 메시지를 생성한다. SOCKET 라이브러리를 통해 OS TCP/IP계층에 전달하는데 먼저 TCP/IP로 IP, PORT 정보를 가지고 서버랑 연결을 한다. 그리고 OS에 데이터를 전달하면 TCP/IP에서 HTTP메세지를 포함한 패킷으로 만들어진 후 서버로 가게 된다. 도착하면 TCP/IP를 다 까서 버리고 HTTP 메세지를 해석해서 데이터를 찾아 HTTP 응답 메세지를 만들고 똑같이 응답 패킷을 만들어 응답한다.



## HTTP 기본

### 모든 것이 HTTP

- HyperText Transfer Protocol: 문서간 링크를 통해 이동할 수 있는 hypertext를 전송하는 protocol
- 현재는 html, text, image, 파일, json등 모든 형태 데이터 전송 가능.
- 서버간 데이터를 주고 받을 때도 사용
- HTTP/1.1: **가장 많이 사용, 우리에게 중요** / RFC2616(1999, 50퍼센트 이상이 이거) 이 다음은 2014년에 나온 RFC 7230 ~ 7235 / 2는 성능 개선, 3는 진행중으로 TCP대신 UDP 사용. 2, 3도 증가하고 있다. 구글 사용
- 기반 프로토콜
  - TCP: HTTP/1.1, HTTP/2
  - UDP: HTTP/3
- 특징: 클라이언트 서버 구조, 무상태 프로토콜(스테이트리스), 비연결성, http 메시지, 단순함, 확장 가능

### 클라이언트 서버 구조

- Request Response 구조: 클라이언트가 서버에 요청 보내고 응답 대기. 서버가 요청에 대한 결과를 만들어 응답. 이렇게 클라이언트와 서버를 분리해야 비지니스 로직, 데이터를 서버에 두고 클라이언트는 사용성, ui에 집중해 각각 발전할 수 있었다.

### Stateful, Stateless

- 무상태 프로토콜. 서버가 클라이언트의 상태를 보존하지 않는다. 
- 장점은 서버 확장성 높음(스케일 아웃 - 수평 확장 유리)
- 단점은 클라이언트가 추가 데이터 전송
- 상태 유지 - Stateful: 가게에서 손님 응대를 하며 중간에 점원이 계속 바뀐다면? 새로온 점원은 앞서 정했던 물건이나 결제 방식을 알 수 없다. 따라서 앞선 상태 유지가 되고 있어야 한다. 
  - 같은 기능을 하는 서버가 여러개 있어도 항상 같은 서버가 유지되어야 한다. 그래서 중간에 갑자기 서버가 죽으면 처음부터 다시 진행해야 한다.
- 무상태 - Stateless: 고객이 계속 앞서 정했던 자신의 상태를 새 요청을 할 때 언급한다. 이럴경우 고객이 증가하면 점원을 대거 투입할 수 있다.
  - 클라이언트 요청이 갑자기 증가해도 서버 대거 투입 가능
  - 응답 서버를 쉽게 바꿀 수 있어 **무한한 서버 증설 가능**
  - 서버 에러가 발생해도 요청 계속 진행 가능
  - 단점은 전송되는 데이터가 많다.

- 그러나 모든 경우에서 사용할 수는 없다. 로그인같은 경우는 상태 유지가 필요하다.(로그인 한 사용자의 상태를 서버에 유지)
- 일반적으로 브라우저 쿠키, 서버 세션을 사용해 유지한다.
- 상태 유지는 최소한만 사용해야 한다.

### 비연결성(connectionless)

- 연결을 유지하면 클라이언트가 각각 한 서버에 요청을 보내면 서버는 연결을 계속 유지하며 서버 자원을 소모한다.
- 연결을 유지하지 않으면 요청에 대한 응답이 오면 바로 연결을 유지하지 않고 서버에서 최소한의 자원을 유지한다.
- HTTP는 기본이 연결을 유지하지 않는 모델. 일반적으로 초 단위 이하의 빠른 속도로 응답하며 서버 자원을 효율적으로 사용한다.
- 1시간 동안 수천명이 서비스를 이용해도 실제 서버에서 동시 처리하는 요청은 수십개 이하로 매우 작다.(모두 동시에 계속 서비스를 요청하는건 아니니까) 
- 비연결성의 한계와 극복: TCP/IP 연결을 새로 맺어야해서 3 way handshake 시간이 추가되고 요청하면서 html, js, css 등 많은 자원이 함께 다운로드 된다.
  - 현재 HTTP 지속 연결(Persistent Connections)로 문제 해결
  - HTTP/2, 3에서 더 많은 최적화
- 초기에 html 응답하고 종료했다가 js필요하면 또 연결해서 받고 종료하고 이런과정을 반복했다. 지속연결을 하면 연결 상태에서 요청-응답을 하며 유지하다가 종료한다.
- `스테이트리스`를 기억해야 한다. 서버 개발자들이 같은 시간에 사람들이 몰리는 업무를 가장 어려워한다. 
- 첫페이지는 정적 페이지만 두고 사람들이 그 안에서 있게 하다가 참여하게 하거나 그렇다.

### HTTP 메시지

- 구조: start-line(시작 라인) - header(헤더) - empty line(공백 라인, CRLF. 무조건 있어야 함) - message body
- start-line = request-line / status-line
  - request-line = method SP(공백), requeset-target, SP, HTTP-version, CRLF(엔터)
  - requeset-target: `absolute-path[?query`](절대경로?[쿼리]), (절대경로는 /로 시작하는 경로)
  - HTTP version
  - status-line = HTTP-version SP status-code SP reason-phrase CRLF
  - status-code: 200성공, 400클라이언트 요청 오류, 500서버 내부 오류
  - reason-phrase: 사람이 이해할 수 있는 짧은 상태코드 설명 글
- header
  - header-field = field-name ":" OWS(띄어쓰기 허용) field-value OWS 
  - field-name 대소문자 구분 없음
  - ex: HOST: www.google.com (host바로 뒤는 띄어쓰기 x : 뒤는 가능)
  - http 전송에 필요한 모든 부가 정보가 들어 있다. 바디 내용, 크기, 압축여부, 인증정보 등
  - 표준 헤더가 매우 많으며 필요시 임의 추가 가능
- 메세지 바디: 실제 전송할 데이터. byte로 표현가능한 모든 데이터 전송 가능
- http 메시지는 단순하지만 확장 가능하다.



## HTTP 메서드

### HTTP API를 만들어보자

- API URI 설계할 때 가장 중요한 것은 **리소스 식별**
- 리소스: `회원`이라는 개념 자체. 등록이나 수정 삭제같은건 제외하고 회원만 식별해서 URI에 매핑
- 리소스를 식별하고 URI 계층 구조를 활용한다. 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장
  - 예시: /members/{id}
- 리소스와 행위를 분리한다. URI는 리소스만 식별하고 리소스를 대상으로 하는 행위(메서드)는 분리해야 한다.



### HTTP 메서드 - GET, POST, PUT, PATCH, DELETE

- GET: 리소스 조회 / 메세지 바디를 사용해 데이터를 전달할 수 있지만 지원하지 않는 곳이 많아 권장X
- POST: 요청 데이터 처리, 주로 등록에 사용 / 메시지 바디를 통해 서버로 요청 데이터 전달. 
  - HTML 양식에 입력된 필드같은 데이터 블록을 데이터 처리 프로세스에 제공: 회원가입, 주문
  - 게시판, 블로그 등에 게시
  - 서버가 식별하지 않은 새 리소스 생성: 주문
  - 기존 자원에 데이터 추가
  - 리소스 URI에 POST요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 정해야 한다. 단순히 데이터를 생성, 변경하는게 아니라 `프로세스 처리`를 해야할 때, 예를 들어 주문-> 결제완료-> 배달시작->배달완료같은 경우
  - POST 결과로 새로운 리소스가 생성되지 않을 수도 있다.
  - 어쩔수 없이 리소스만으로 설계할 수 없을 때가 있다. POST /orders/{orderId}/start-delivery: `컨트롤 URI`
  - 다른 메서드로 처리하기 애매한 경우. JSON으로 조회 데이터를 넘겨야 하는 GET을 사용하기 어려운 경우(메세지 바디를 허용하지 않으니까) 조회여도 POST를 사용한다. 
- PUT: 리소스 대체, 해당 리소스 없으면 생성 / **클라이언트가 리소스 식별**, 클라이언트가 리소스 위치를 알고 URI를 지정한다. 그런데 리소스 중 하나만 수정하기 위해 데이터를 보내면 완전히 대체하기 때문에 기존 리소스 중 없는 데이터는 사라진다.
- PATCH: 리소스 부분 변경 / PUT은 완전 대체하지만 PATCH는 보내지 않은 리소스도 삭제하지 않는다. / PATCH를 지원하지 않는 서버가 있는데 그 때는 POST를 사용한다.
- DELETE: 리소스 삭제
- HEAD: GET과 동일하지만 메세지를 제외한 상태줄, 헤더만 반환
- OPTIONS: 대상 리소스에 대한 통신 가능 옵션을 설명 주로 CORS
- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널 설정 - 거의 사용 안함
- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행 - 거의 사용 안함



### HTTP 메서드의 속성

- 안전(Safe Methods): 호출해도 리소스 변경이 없는걸 말한다. GET은 안전 POST, DELETE등은 아님. 그런데 호출을 계속해서 로그가 쌓여 장애가 발생한다해도 안전은 리소스만 고려한다.
- 멱등(Idempotent): 몇 번을 호출해도 결과가 같다. GET, PUT, DELETE도 멱등. 같은 요청을 여러번해도 결과는 같으니까. POST는 아니다. 두 번 호출하면 두 번 결제될 수 있다.
  - 자동 복구 메커니즘. delete했는데 답이 안왔을 때 다시 같은 요청해도 되는가 판단하는 근거가 된다.
  - 재요청 중간에 누가 데이터를 변경한다면? 멱등은 그런것 까지는 고려하지 않는다.
- 캐시가능(Cacheable): GET, HEAD, POST, PATCH 캐시가능하지만 실제로는 GET, HEAD정도만 사용. POST, PATCH는 본문 내용을 캐시 키로 고려해야 하는게 쉽지 않다.



## HTTP 메서드 활용

### 클라이언트에서 서버로 데이터 전송

- 데이터 전달 방식
  - 쿼리 파라미터: GET, 주로 정렬 필터(검색어)
- 메시지 바디를 통한 데이터 전송
  - POST, PUT, PATCH, 가입, 주문, 리소스 등록과 변경
- 클라이언트 -> 서버 데이터 전송 4가지 상황
  - 정적 데이터 조회: 이미지, 문서 / 보통 쿼리 파라미터 없이 경로만으로 조회 가능
  - 동적 데이터 조회: 검색, 정렬 필터 / 쿼리 파라미터 사용
  - HTML Form: 가입, 주문 등 / Content-Type: application 사용. form 내용을 메세지 바디를 통해 쿼리 파라미터 형식으로 전송하며 데이터 url encoding 처리 / GET, POST만 지원
    - Content-Type: x-www-form-urlencoded, multipart/form-data / 파일 업로드 같은 바이너리 데이터 전송시 사용 / 다른 종류 여러 파일과 폼 내용 함께 전송.
  - HTTP API: 가입, 주문 등. 서버 to 서버, 앱과 웹 클라이언트 - Ajax / Content-Type: application/json이 사실상 표준



### HTTP 설계 예시

- POST로 등록할 때 보통 서버에서 URI를 만들어서 등록한다. 클라이언트는 등록될 리소스 URI를 모른다. `대부분 이걸 사용`
- PUT으로 등록할 때는 클라이언트가 리소스 URI를 지정해야 한다. 거의 사용안한다.
  - 스토어(Store): 클라이언트가 관리하는 리소스 저장소. 클라이언트가 리소스의 URI를 알고 관리. (예를 들어 PUT 요청으로 파일을 등록할 때 /files/{filename}으로 요청을 보낸다면 스토어는 /files가 된다.)
- 컬렉션: 서버가 관리하는 리소스 디렉토리. 서버가 리소스의 URI를 등록하고 관리(예를 들어 POST요청으로 회원등록할 때 /members 라고 보낸다면 members가 컬렉션이다.)
- 컬렉션으로 관리하는 느낌을 줄지 아니면 뒤에 /edit을 붙일지는 선택이지만 폼을 가져올 때 GET /edit을 사용하는데 이와 형식을 맞추는걸 선호하는 편(강사님은).
- HTML FORM을 사용할 때는 GET, POST만 가능해 제약이 있어 동사로 된 리소스 경로를 사용한다. /new, /edit, /delete 등을 컨트롤 URI라고 함. HTTP 메서드로 해결하기 애매할 때 사용

- URI설계 개념
  - 문서: 단일 개념. 파일 하나, 객체 인스턴스, DB row 예) files/star.jpg
  - 컬렉션: 서버가 관리하는 리소스 디렉터리. 서버가 리소스 URI 생성, 관리 예) /members
  - 스토어: 클라이언트가 관리하는 자원 저장소. 클라이언트가 리소스의 URI를 알고 관리. 예) /files
  - 컨트롤러, 컨트롤 URI: 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행. 동사 직접 사용. 예) /members/{id}/delete



## HTTP 상태코드

- 클라이언트가 보낸 요청의 처리 상태 응답에서 알려주는 기능
- 1XX(Informational): 요청 처리되어 수신 중 / 거의 사용하지 않는다.
- 2XX(Successful): 요청 정상 처리
  - 200 OK / 201 Created, 생성된 리소스는 응답의 Location 헤더 필드로 식별 / 202 Accepted, 접수는 됐지만 처리 완료X. 배치 처리같은 곳에 사용 / 204 No content, 요청 성공, 응답 페이로드 본문에 보낼 데이터 없음.
- 3XX(Redirection): 요청 완료하려면 추가 행동 필요 / 응답 결과에 Location 헤더가 있으면 자동 이동 / 영구 리다이렉션, 일시 리다이렉션(PRG, 주문 완료 후 주문 내역 이동 같은 경우), 특수 리다이렉션(결과 대신 캐시 사용) / 본문이 제거되는 코드는 100%는 아니지만 거의 그렇다.
  - 300 Multiple Choices, 거의 안씀 / 301 Moved Permanently, 요청이 GET으로 바뀌고 본문이 제거될 수 있다. / 302 Found, 요청이 GET으로 바뀌고 본문이 제거될 수 있다. / 303 See Other, 요청이 GET으로 바뀐다. / 304 Not Modified, 캐시 목적으로 사용. 클라이언트에게 리소스가 수정되지 않았다는걸 알려줌. 클라이언트가 로컬 PC의 캐시 재사용함(캐시로 리다이렉트), 로컬 캐시를 사용해야하니 응답에 메시지 바디를 포함하면 안되고 조건부 GET, HEAD 요청시 사용 / 307 Temporary Redirect, 요청 메서드와 본문 유지 / 308 Permanent Redirect, 요청 메서드와 본문 유지
  - `PRG`: Post/Redirect/Get. POST로 주문 후 웹 브라우저를 새로고침하면 다시 요청될 수 있다. 이를 방지하기 위해 GET메서드로 리다이렉트해 새로고침해도 GET요청이 다시 일어나게 한다.
  - 원래 302의도는 HTTP 메서드 유지 -> 브라우저 대부분 GET으로 바꿈 -> 모호한 302대신 307, 303등장. 301대신 308등장. 권장은 307, 303이지만 많이 사용하는 302를 써도 문제는 없다.
- 4XX(Client Error): 클라이언트 오류, 잘못된 문법으로 서버가 요청 수행 불가능. 똑같은 재시도는 실패 / 요청 구문, 메세지 등 오류. 
  - 401 Unauthorized, 클라이언트가 해당 리소스에 대한 인증 필요. 응답에 WWW-Authenticate 헤더와 함께 인증 방법 설명. 인증은 보인이 누구인지 확인하는 거고 인가(Authorization)은 권한 부여를 의미해서 약간 이름이 이상.
  - 403 Forbidden, 인증 자격 증명 있지만 접근 권한 불충분
  - 404 Not Found, 요청 리소스가 서버에 없음. 혹은 클라이언트가 권한이 부족한 리소스 접근해 숨길 때
- 5XX(Server Error): 서버 오류, 서버 정상 요청 처리 못함. 재시도하면 성공할 수도 있음(복구) / 이건 진짜 서버에 문제가 있지 않은 이상 만들지 말자.
  - 503 Service Unavailable, 일시적 과부하나 예정된 작업으로 잠시 요청 처리 불가. Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼수도 있다.



## HTTP 헤더1 - 일반 헤더

- HTTP BODY
  - RFC2616(과거) => 폐기: 메세지 본문은 엔티티 본문 전달에 사용. 엔티티 본문은 요청, 응답에서 전달할 실제 데이터. 엔티티 헤더는 본문의 데이터를 해석할 수 있는 정보 제공 -> 데이터 유형, 길이, 압축 정보 등
  - 엔티티 -> 표현: 표현은 표현 메타데이터 + 표현 데이터
  - RFC7230~7235(현재): 메시지 본문을 통해 표현 데이터 전달. 메시지 본문 = 페이로드(payload) / 표현(요청, 응답에서 전달할 실제 데이터). 표현 헤더(표현 데이터를 해석할 정보)



### 표현

- 표현 리소스를 html? json?
- 표현 헤더는 전송, 응답 둘 다 사용.
- Content-Length: 표현 데이터 길이, 바이트 단위, Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨



### 콘텐츠 협상

- 클라이언트가 선호하는 표현 요청. 
- Accept: 미디어 타입 전달
- Accept-Charset: 문자 인코딩
- Accept-Encoding: 압축 인코딩
- Accept-Language: 자연 언어 / 다중 언어를 지원하는 서버일 때 한국어로 보이도록. 근데 독일어, 영어만 지원하는 서버라면? 
- 협상 헤더는 요청시에만 사용
- 협상과 우선순위(Quality Values(q)): 0~1사이 클수록 높은 우선순위. 생략하면 1
  - 예시: ko-KR,ko:q=0.9,en-US;Q=0.8
- 협상과 우선순위2: 구체적인 것이 우선한다.
  - 예시: text/*, text/plain, text/plain;format=...
- 협상과 우선순위3: 구처젝인 것을 기준으로 미디어 타입을 맞춘다. 각자 정해진 quality값이 있는데  기본 값과 다르면 구체적인 걸 기준으로 맞춘다.



### 전송방식

- 단순
- 압축: Content-Encoding 추가로 보내기
- 분할: Transfer-Encoding: chunked 추가로 보내기 / 5 Hello / 5 World / 0 \r\n(끝 의미) 처럼 바이트 단위 / Content-Length 보내면 안된다.
- 범위: Content-Range 추가로 보내기. 받다가 끊겼을 때 지정 범위만 다시 받을 수 있도록.



### 일반 정보

- From: 유저 에이전트의 이메일 정보. 일반적으로 사용되지 않지만 검색 엔진에서 주로 사용. 요청에서 사용
- Referer: 현재 요청된 페이지의 이전 페이지 주소. A->B 이동시 A의 주소를 가지고 이동. / 이용해서 유입경로 분석 가능. 요청에서 사용 / referrer의 오타인데 그냥 쓴다.
- User-Agent: 클라이언트 애플리케이션 정보(웹 브라우저 등) / 통계 / 어떤 브라우저에서 장애가 발생하는지 파악 가능 / 요청에서 사용
- Server: 요청 처리하는 ORIGIN 서버의 소프트웨어 정보 / http 요청 보내면 여러 프록시 서버를 거치는데 내 요청에 응답하는 진짜 서버를 오리진 서버라고 한다 / 응답에서 사용
- Date: 메시지가 발생한 날짜, 시간 / 응답에서 사용



### 특별한 정보

- Host: 요청한 호스트 정보(도메인) / `필수` / 한 서버가 여러 도메인 처리해야 할 때 / 하나의 ip 주소에 여러 도메인이 적용되어 있을 때(가상 호스트를 통해 실제 여러 애플리케이션 구동) / 요청에서 사용
- Location: 3xx 응답 결과에 Location 헤더가 있으면 그 위치로 자동 이동. 201(created)에서는 요청에 의해 생성된 리소스 URI
- Allow: 허용 가능한 HTTP 메서드. 405(Method Not Allowed)에서 응답에 포함해야 함. GET, HEAD, PUT / 그리 많이 사용하지는 않는다.
- Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간. 503(Service Unavailable) 서비스가 언제까지 불능인지 알려줄 수 있음. 날짜 표기 또는 초단위 표기



### 인증

- Authorization: 클라이언트 인증 정보 서버에 전달 
- WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의 / 401 Unauthorized 응답과 함께 사용



### 쿠키

- Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
- Cookie: 클라이언트가 서버에서 받은 쿠키 저장하고 http 요청시 모든요청에 쿠키 정보 자동 포함해 서버로 전달
- 쿠키를 사용하지 않으면 로그인 후 다시 첫페이지로 가면 내 정보를 기억하고 있지 않다. 
- Stateless: http는 무상태 프로토콜이라 요청과 응답 주고 받으면 연결이 끊어져 다시 요청하면 이전 요청을 기억하지 못한다. 서로 상태를 유지하지 않는다.
- 사용처: 사용자 로그인 세션 관리 / 광고 정보 트래킹
- 쿠키 정보는 항상 서버에 전송되므로 네트워크 트래픽을 추가 유발한다. 따라서 최소한의 정보만 사용(세션 id, 인증 토큰) / 서버에 전송하지 않고 웹 브라우저 내부에 데이터를 저장하려면 웹 스토리지(localStorage, sessionStorage)
- `보안에 민감한 데이터는 안됨(주민번호, 카드번호)`
- 보내는 것 예시: sessionId, expires, path, domain, Secure, max-age 등
- 세션 쿠키: 만료 날짜 생략하면 브라우저 종료시 까지만 유지
- 영속 쿠키: 만료 날짜 입력하면 해당 날짜까지 유지
- 도메인 지정 가능: 명시한 문서 기준 도메인 + 서브 도메인 포함해서 전송. 도메인 생략하면 문서 기준 도메인에서만
- 경로: 이 경로 포함한 하위 경로 페이지만 쿠키 접근.
- 보안: Secure(https만 전송) / HttpOnly(XSS공격 방지, 자바스크립트에서 접근 불가) / SameSite(XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 전송)



## HTTP 헤더2 - 캐시와 조건부 요청

### 캐시 기본 동작

- 캐시가 없을 때 응답에서 HTTP 헤더 + HTTP 바디 응답 / 데이터가 변경되지 않아도 계속 네트워크 통해서 데이터 다운로드 받아야 함. 인터넷 네트워크는 매우 느리고 비싸고 브라우저 로딩 속도가 느리다.
- 캐시 적용하면 응답에서 cache-cntrol: max-age 헤더와 함께 응답해 지정 시간만큼 응답 결과를 브라우저 캐시에 저장해둔다. 캐시 가능 시간동안 네트워크를 사용하지 않아도 돼서 비싼 네트워크 사용량을 줄이고 브라우저 로딩 속도가 빠르다.
- 캐시 시간 초과 후 다시 요청하면 서버 통해 다시 조회하고 갱신해서 네트워크 다운로드가 재발생.



### 검증 헤더와 조건부 요청1

- 캐시 유효시간이 초과해 재요청하면 서버에서 기존 데이터를 변경하는 경우와 변경하지 않은 경우가 있다. 
- 데이터가 바뀌지 않은 경우: 저장해뒀던 캐시 재사용하면서 클라이언트 데이터와 서버 데이터 같다는 사실 확인할 방법 필요.
  - 검증 헤더 추가: Last-modified가 첫 응답에 함께 들어간다. 다음 요청할 때 클라이언트가 이 값을 함께 보내면 304 Not Modified와 cache-control을 다시 보내면서 HTTP Body도 없다. 클라이언트는 응답 헤더 정보로 캐시 메타 정보 갱신. 결과적으로 헤더 정보만 네트워크 다운로드 한다.



### 검증 헤더와 조건부 요청2

- 검증 헤더: 캐시 데이터, 서버 데이터가 같은지 검증하는 데이터 / Last-Modified, ETag
- 조건부 요청 헤더: 검증 헤더로 조건에 따른 분기. 
  - If-Modified-Since: Last-Modified 사용 / 단점: 1초 미만 단위로 캐시 조정 불가능, 날짜 기반 로직 사용, 데이터를 수정해서 날짜가 다르지만 같은 데이터를 수정해서 데이터 결과가 같으면 수정된걸로 본다. 서버에서 별도 캐시 로직을 관리하고 싶은 경우(주석처럼 크게 영향없이 캐시 유지하고싶을 때)에도 불가
  - If-None-Match: ETag 사용
  - 조건 만족하면 200 OK, 만족안하면 304 Not Modified
- Etag: 캐시용 데이터에 임의의 고유한 버전 이름 달아둠. 데이터가 변경되면 이 이름 바꾸어서 변경함(Hash 다시 생성) / ETag를 보내서 같으면 유지하고 다르면 다시 받기 / 캐시 제어 로직을 서버에서 완전히 관리. 클라이언트는 단순히 값을 서버에 제공. / 예를 들어 애플리케이션 배포 주기에 맞춰 ETag 모두 갱신



### 캐시와 조건부 요청 헤더

- Cache-Control: max-age (캐시 유효 시간, 초 단위) / no-cache(데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용) / no-store(데이터에 민감정보 있으므로 저장X) 
- Pragma: 캐시 제어( no cache처럼 동작하지만 http 1.0 하위 호환)
- Expires: 캐시 만료일 지정. 하위호환 / http 1.0부터 사용 / Cache-Control: max-age 사용을 권장해 이걸 사용할 경우 expires무시



### 프록시 캐시

- 한국에 여러 클라이언트가 미국 서버에 접근할 때 응답이 너무 느리므로 한국에 프록시 캐시 서버를 만들어 이걸 거쳐서 요청이 오게 한다. 그래서 한국 사람들이 많이 보는 외국 컨텐츠는 빠르게 볼 수 있다. 프록시 캐시 서버는 public 캐시고 클라이언트가 private 캐시
- 캐시 지시어(directives): public(public 캐시에 저장되어도 됨) / private(해당 사용자만을 위한 것, 기본 값) / s-maxage(프록시캐시에 적용되는 max-age) / Age(http헤더, 오리진 서버 응답 후 프록시 캐시에 머문 시간)



### 캐시 무효화

- 확실한 캐시 무효화 응답: Cache-Control: no-cache, no-store, must-revalidate에 하위호환 고려하면 Pragma: no-cache까지
  - must-revalidate: 캐시 만료 후 조회 시 원서버에 검증. 원서버 접근 실패시 반드시 오류 발생 504(Gateway Timeout) / no-cache는 항상 원서버 검증
  - 동작 차이: no-cache는 프록시 서버에 요청하면 원 서버까지 가서 요청후 응답을 받는다. 원 서버에 접근할 수 없으면 캐시 서버 설정에 따라 오류보다 오래된 데이터라도 보여준다. must-revaldiate는 원 서버에 접근 불가능하면 항상 오류가 발생한다.



## 다음으로

- 인터넷에 정확하지 않은 정보가 많으므로 강의 내용 기반으로 확인할것.
- RFC2616을 공부하지말고 RFC 7230~7235기반으로 볼 것
- HTTP 완벽가이드 책도 너무 좋지만 RFC 2616기준이다. 그래도 좋음.
