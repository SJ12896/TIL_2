## Java의 정석

### Chapter01 자바를 시작하기 전에

#### 1.1 자바란?

- 썬 마이크로시스템즈에서 개발한 객체지향 프로그래밍 언어
- 운영체제에 독립적이어서 종류에 관계없이 실행가능해 프로그램을 전혀 변경하지 않고도 실행이 가능
- 풍부한 클래스 라이브러리(Java API)를 통해 프로그래밍에 필요한 요소들을 기본적으로 제공



#### 1.3 자바언어의 특징

1. 운영체제에 독립적: 자바 프로그램이 운영체제, 하드웨어가 아닌 에뮬레이터 `자바가상머신(JVM)`하고만 통신해 JVM이 받은 명령을 해당 운영체제가 이해할 수 있도록 변환해 전달한다. JAVA로 작성한 프로그램과 달리 JVM은 운영체제에 종속적이어서 서로 다른 버전의 JVM이 제공되고 있다. Write once, Run anywhere
2. 객체지향언어: 상속, 캡슐화, 다형성이 잘 적용되었다. 재사용성 & 유지보수의 용이성
3. 비교적 배우기 쉬움: C++과 스몰톡의 장점을 취하고 복잡한 부분은 제거. 많은 장점에도 불구하고 배우기 어려웠던 객체지향 프로그래밍의 저변 확대에 큰 기여를 했다.
4. 자동 메모리 관리(Garbage Collection): 자바 프로그램이 실행되면 가비지 컬렉터가 자동적으로 메모리를 관리해줘 프로그래머가 수동적으로 사용하지 않는 메모리를 체크하고 반환하는 관리가 필요 없다.
5. 네트워크와 분산처리 지원: 라이브러리를 통해 비교적 짧은 시간에 네트워크 관련 프로그램 쉽게 개발
6. 멀티쓰레드 지원: 일반적으로 운영체제에 따라 구현방법과 처리방식이 다르지만 자바에서 개발되는 멀티쓰레드 프로그램은 시스템과 관계없이 구현 가능하며 라이브러리가 제공되어 쉽다. 여러 쓰레드에 대한 스케줄링을 자바 인터프리터가 담당한다.
7. 동적 로딩 지원(Dynamic Loading): 보통 자바 애플리케이션은 여러 클래스로 구성되는데 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 로딩할 수 있다. 또 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 되고 비교적 적은 작업으로 변경사항을 처리할 수 있다.



#### 1.4 JVM(Java Virtual Machine)

- 자바를 실행하기 위한 가상 컴퓨터(소프트웨어로 구현된 컴퓨터)
- 가상 기계: 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어
- 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되는데 자바 애플리케이션은 JVM을 거쳐야하고 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시 해석되기 때문에 속도가 느리다는 단점이 있었다.  그러나 바이트코드(컴파일된 자바코드)를 하드웨어 기계어로 바로 변환하는 JIT 컴파일러와 Hotspot같은 신기술 도입으로 JVM 기능이 향상되어 속도문제가 개선되었다.



#### 2. 자바개발환경 구축하기

#### 2.1 자바 개발도구(JDK) 설치하기

- 자바 프로그래밍을 위해서 먼저 JDK(Java Development Kit)를 설치해야 한다. JDK를 설치하면 JVM, 자바클래스 라이브러리와 개발에 필요한 프로그램들이 설치된다. 
- JDK설치 후 설치 디렉토리 bin을 path에 추가해야한다. 이 디렉토리에 자바로 프로그램을 개발하는데 필요한 실행파일들이 있다. path는 OS가 파일 위치를 파악하는데 사용하는 경로로 path에 디렉토리를 등록하면 해당 디렉토리에 포함된 파일을 경로없이 이름만으로 사용할 수 있게 된다. 
- JDK bin 디렉토리의 주요 실행파일들: javac.exe(자바 컴파일러. 소스코드를 바이트코드로 컴파일) / java.exe(자바 인터프리터. 컴파일러가 생성한 바이트코드 해석하고 실행) / javap.exe(역어셈블러. 컴파일된 클래스파일을 원래 소스로 변환) / javadoc.exe(자동문서생성기. 소스파일의 주석을 이용해 API문서같은 형식 문서를 자동 생성) / jar.exe(압축프로그램. 클래스파일과 프로그램 실행 관련 파일을 하나의 jar파일로 압축하거나 압축해제한다.)
- JRE: 자바실행환경(Java Runtime Enviornment). 자바로 작성된 응용프로그램이 실행되기 위한 최소환경
- JDK = JRE + 개발에 필요한 실행파일
- JRE = JVM + 클래스 라이브러리(Java API)



#### 2.2 Java API문서 설치하기



### 3. 자바로 프로그램작성하기

#### 3.1 Hello.java

- 자바에서 모든 코드는 반드시 클래스 안에 존재해야 하고 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스를 구성하게 된다. 
- 소스파일의 이름은 public class의 이름과 일치해야 한다. 소스파일 내에 public class가 없다면 소스파일 이름은 소스파일 내의 어떤 클래스 이름으로 해도 상관없다. 
- 소스파일(.java)과 달리 클래스파일(.class)은 클래스마다 하나씩 만들어진다.



#### 3.2 자주 발생하는 에러와 해결방법

#### 3.3 자바 프로그램 실행과정

1. 프로그램 실행에 필요한 클래스를 로드한다.
2. 클래스 파일을 검사한다.
3. 지정된 클래스에서 main메서드를 호출한다.



### Chapter02 변수

### 1. 변수(variable)

- 단 하나의 값을 저장할 수 있는 메모리상의 공간
- 메모리는 여러 프로그램이 공유하는 자원으로 다른 프로그램에 의해 저장된 알 수 없는 값이 남아있을 수 있어 사용 전 **초기화**(사용하기 전 처음으로 값 저장) 해야한다.
- 변수 사용가능 특수문자: _ $
- 필수는 아니지만 권장하는 규칙: 클래스 이름 첫 글자는 항상 대문자 / 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 / 상수 이름은 모두 대문자며 여러 단어인 경우 _로 구분



### 2. 변수의 타입

- 자료형은 크게 기본형 / 참조형으로 나뉜다.
  - 기본형: 실제 값 저장 / C언어와 달리 참조형 변수간 연산 불가능, 실제 연산에 사용되는건 boolean을 제외한 기본형이므로 서로 변환 가능 / 논리형(boolean), 문자형(char), 정수형(byte, short, **int**, long), 실수형(float, **double**)
  - 참조형: 어떤 값이 저장된 주소 / 기본형 제외한 나머지 / JVM이 32 bit면 4 byte, 64 bit면 8 byte
- 참조형 변수를 선언할 때 변수 타입으로 클래스 이름을 사용한다. 클래스 이름은 참조변수 타입이 되므로 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.
- int는 대략 10자리수(약 20억)의 값을 저장할 수 있다.
- 실수형은 큰 값을 저장할 수 있지만 오차가 발생할 수 있다. float은 정밀도가 7자리로 10진수 7자리의 수를 오차없이 저장, dobule은 15자리

#### 2.2 상수와 리터럴

- JDK 1.6부터 상수를 선언과 동시에 초기화 하지 않아도 된다. 하지만 선언과 동시에 초기화하는 편이 좋다. 상수를 사용하면 다른 값을 계산할 때 여러 곳 수정할 필요 없고 이해와 수정을 돕는다.
- 리터럴: 그 자체로 값을 의미하는 것

- 접미사: L(정수 long 타입일 경우) / f, d(double이 기본이라 생략 가능) / 대소문자 상관X
- 접두사:  0을 붙이면 8진수, 0x는 16진수, 0b는 2진수로 저장 / 대소문자 상관X
- JDK 1.7부터 정수형 리터럴 중간에 구분자_를 넣어 큰 숫자를 편하게 읽을 수 있게 했다.
- 리터럴에 소수점이나 십의 제곱을 나타내는 e 또는 접미사 f, d등이 있으면 실수형으로 간주, 드물지만 p도(2의 제곱 의미하며 16진 지수형태 표현)
- 타입의 불일치: 저장범위가 넓은 타입에 좁은 값 저장은 허용
- 문자 리터럴: 작은 따옴표로 문자 하나 감싼 것으로 반드시 ''안에 하나의 문자 필요



#### 2.3 형식화된 출력 - printf()

- 지시자를 이용해 변수 값을 여러 형식으로 변환해 출력한다. 지시자 개수 제한은 없으며 줄바꿈을 하려면 %n을 넣어준다.(\n도 가능하지만 OS마다 다를 수 있어 %n 권장)
- %b: boolean / %d: 10진(decimal) / %o: 8진(octal) / %x: 16진(hexa) / %f: 부동소수점(floating-point) / %e: 지수(exponent) / %c: 문자(character) / %s: 문자열(string)
- 출력될 값이 차지할 공간을 숫자로 지정 가능
  - %와 지시자 사이에 숫자가 공간 크기
  - 크기 앞에 -를 붙이면 오른쪽부터 공간 차지
  - 숫자나 문자를 써넣으면 해당 글자가 남는 공간을 차지
  - .숫자를 써넣으면 왼쪽에서부터 숫자만큼만 출력
  - %f는 기본적으로 6자리만 출력하므로 7번째에서 반올림된다. 따라서 숫자.숫자를 사용해 소수 자리수를 지정가능한다. 모자르면 0으로 채워진다.
- %x(%X), %o에 #을 사용하면 0x, 0이 붙는다.
- 10진수 -> 2진수로 출력하는 지시자는 없기 때문에 문자열 지시자를 사용후 Integer.toBinaryString(binNum)을 이용한다.
- char타입을 %d로 출력할 수 없다. 형변환 필요



#### 2.4 화면에서 입력받기

- 연속적으로 값을 입력받을 때 nextLine()으로 입력받은 후 변환하는 것을 추천한다.



### 3. 진법

#### 3.2 비트와 바이트

- 비트: 한 자리의 2진수 / 1비트는 컴퓨터가 값을 저장할 수 있는 최소단위
- 바이트: 1 비트는 너무 작아 1 비트를 8개 묶어 바이트로 정의하고 데이터 기본 단위로 사용
- 워드: CPU가 한 번에 처리할 수 있는 데이터의 크기. CPU 성능에 따라 달라져 32비트에선 32비트고 64비트에선 64비트가 된다.

#### 3.3 진법변환

- 2진수 -> 8진수: 2진수를 뒤에서부터 3자리씩 끊어 해당하는 8진수로 바꾼다. 
- 10진 소수점수 -> 2진 소수점수: 10진 소수점수에 2를 곱해서 나온 결과에서 소수부만 가져다 계속 2를 곱한다. 소수부가 0이 될때까지 반복한다. 그리고 곱한 결과 값에서 정수부만을 위에서 아래대로 적고 0.을 붙이면 된다.



#### 3.6 음수의 2진 표현 - 2의 보수법

- n비트의 2진수로 표현할 수 있는 값의 개수는 2ⁿ개로 모두 부호없는 정수다. 
- 음수를 표현하는 법1: 1로 시작하는 2진수를 음수표현에 사용하고 순차적으로 -0부터 시작한다. 하지만 두 수를 더했을 때 2진수로 0이 되지않고 2개의 0이 존재하는 단점이 있다. 또 2진수가 증가할 때 10진 음수는 감소한다.
- 2의 보수법
  - 절대값이 같은 양수 음수를 더했을 때 2진수로도 0의 결과를 얻게되고 2진수가 증가할 때 10진 음수도 증가한다. 
  - n의 보수: 더했을 때 n이 되는 수
  - 2진수로 10은 **자리올림이 발생하고 0이 되는 수를 뜻한다.** (이 부분 약간 애매. 더 찾아볼 것)
  - 음수를 2진수로 표현하기 위해서는 절대값의 2진수를 구한 후 2의 보수를 구하면 된다.
  - 2의 보수 = 1의 보수 + 1 / 2진수에서 1의 보수를 더하면 모든 자리가 1이 된다. 여기서 양변에 1을 더하면 우변은 0이 되는데 올림이 발생하지만 4비트를 넘어 저장할 공간이 없어 버려진다. 



### 4. 기본형(primitive type)

#### 4.2 문자형 - char

- char에는 문자가 아닌 문자의 유니코드가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장한다. 그래서 문자의 유니코드를 직접 저장해도 동일한 결과를 가진다.
- tab은 \t, backspace는 \b 등 특수문자를 저장할 수 있다.
- char는 2byte(=16bit)로 모두 2¹⁶개의 값을 표현할 수 있고 0포함 모든 양수여야 한다. 반면 short는 같은 크기지만 절반을 음수 표현에 사용한다. char에 A, short에 65를 저장하면 둘 다 2진수로 같은 값이 저장되지만 println()으로 출력할 때 변수 타입이 정수형이면 변수에 저장된 값을 10진수로 해석해 출력하고 문자형이면 저장된 숫자에 해당하는 유니코드 문자를 출력한다.
- 문자 -> 코드: 인코딩, A -> 65
- 코드 -> 문자: 디코딩, 65 -> A
- 유니코드: 전 세계 모든 문자를 하나의 통일된 문자집합으로 표현하고자 노력한 결과. 유니코드에 포함시키고자 하는 문자들의 집합을 정의한 것을 유니코드 문자 셋이라고 한다. 그리고 이 문자셋에 번호를 붙인 것이 유니코드 인코딩이다. UTF-16은 자바에서 사용하며 모든 문자를 2byte 고정 크기로 표현한다. UTF-8은 1~4 byte 가변크기로 표현한다. UTF-16은 1byte로 표현가능한 영어와 숫자도 2byte로 표현되어 문서의 크기가 커지는 단점이 있다. 인터넷에서 문서 크기가 작을수록 전송속도에 좋기 때문에 UTF-8로 작성된 웹문서가 빠르게 늘고 있다.

#### 4.3 정수형 -byte, short, int, long

- 어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다. 
  - 정수형의 저장: 부호비트 + (n-1)bit 
  - n비트로 표현할 수 있는 정수의 개수: 2ⁿ개(최대값은 절반에서 1을 빼야한다. 0도 포함되기 때문)
- 오버플로우: 연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것. 부호없는 정수는 2진수로 0000이 될 때 오버플로우가 발생하고 부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생.
  - 최소값에서 1을 빼면 최대값이 되고 최대값에서 1을 더하면 최소값이 된다.

#### 4.4 실수형 - float, double

- 실수형은 얼마나 큰 값은 표현할 수 있는가 뿐만 아니라 얼마나 0에 가깝게 표현할 수 있는가도 중요하다.
- 실수형에서 오버플로우가 발생하면 변수 값은 무한대가 된다. 그리고 정수형에 없는 언더플로우가 있는데 실수형으로 표현할 수 없는 아주 작은 값, 양의 최소값보다 작은 값이 되는 경우를 말한다.
- 정수형은 부호와 값으로 이루어져있지만 실수형은 부호(S), 지수(E), 가수(M) 세부분으로 이루어져있다. 2의 제곱을 곱한 형태로 저장(+-M * 2의 E승)하기 때문에 큰 범위를 저장하는 게 가능하다. 
- 그러나 정수형과 달리 오차가 발생할 수 있다는 단점이 있다. 실수형은 표현할 수 있는 값의 범위 뿐 아니라 정밀도가 중요한 요소다. 
- 부호: 0이면 양수, 1이면 음수. 정수형과 달리 2의 보수법을 사용하지 않아 양의 실수 -> 음의 실수 하려면 부호비트만 0에서 1로 변경 / 1
- 지수: 부호있는 정수. / float은 8, double은 11
- 가수: 실제값을 저장하는 부분. / float은 23, double은 52 / float 2진수 23자리로 7자리 10진수를 저장할 수 있는데 이게 바로 float의 정밀도가 된다. 



### 5. 형변환

- float을 int로 변환할 때 소수점 이하의 값은 반올림이 아닌 버림 처리된다.
- 실수형간의 형변환
  - float -> double: 지수는 float의 기저인 127을 빼고 double의 기저인 1023을 더해서 변환
  - double -> float: 지수는 double의 기저인 1023을 빼고 float의 기저인 127을 더함. 가수는 double의 가수 52자리 중 23자리만 저장되고 나머지 버림. 그런데 가수 24번째 자리에서 반올림 발생할 수 있다. 24자리가 1이면 23번째 자리가 1이 증가한다. / 또한 float의 범위를 넘는 값을 float으로 형변환하면 플러스마이너스 무한대 또는 플러스마이너스 0을 얻게된다.
- 정수형 -> 실수형: 2진수로 변환 후 정규화를 거쳐 실수 저장형식으로 저장된다. 다만 int는 최대 10자리의 정밀도를 요구하는데 float은 7자리만을 제공하므로 정밀도 차이에 의한 오차가 발생할 수 있다. 
- 실수형 -> 정수형: 소수점 이하 값은 버려진다. 형변환 시 반올림이 발생하지 않는다.
- 자동 형변환: 변수가 저장가능한 값 범위보다 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생하지만 명시해줬을 경우 의도적인 것으로 간주하고 에러를 발생시키지 않는다. 서로 다른 두 타입의 덧셈에서는 표현범위가 더 넓은 타입으로 형변환해 일치시킨 다음 연산을 수행한다. 



## Chapter 03 연산자

- 쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다.
- 비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮다. ex) data & 0xFF == 0 에서 ==먼저 실행
- 보통 왼쪽에서 오른쪽 순서로 연산을 수행하지만 단항 연산자와 대입 연산자만 오른쪽에서 왼쪽 순서로 수행한다. 
- 우선순위: 산술 > 비교 > 논리 > 대입 / 단항 > 이항 > 삼항
- 산술 변환: 피연산자의 타입 일치를 위해 자동으로 형변환되는 것. 보통 둘 중 큰 타입으로 맞춰지지만 피연산자의 타입이 int보다 작다면 int로 변환된다.(byte + short같은 경우) 따라서 byte + byte 결과를 byte 타입의 변수에 저장하려면 형변환이 필요하다.
- 연산결과의 타입은 피연산자의 타입과 일치한다. int와 int를 나눈 결과는 int다. 
- int a, b가 있을 때 long c = a * b이고 결과 값이 int의 범위를 넘어서는 값이라면 결과 변수가 long이라 제대로 계산된 값이 나올 것 같지만 a * b의 값이 이미 int의 값이므로 잘못된 값이 나온다. 따라서 a 또는 b를 long으로 형변환해 계산해야 한다. 
- char c2 = 'a'; c2 = c2 + 1;이란 코드를 작성하면 c2가 계산과정에서 자동으로 int로 형변환되었고 그 결과를 char에 담으려 해서 오류가 발생한다. 하지만 char c2 = 'a' + 1;은 오류가 발생하지 않는데 리터럴 간의 연산이기 때문이다. **상수 또는 리터럴 간의 실행과정동안 변하는 값이 아니기 때문에 컴파일 시 컴파일러가 계산해서 그 결과로 대체**한다. 컴파일러가 미리 덧셈연산을 수행하므로 실행 시에는 연산이 수행되지 않는다. 그러나 수식에 변수가 들어가 있는 경우 컴파일러가 미리 계산할 수 없어 형변환이 필요하다.
- 비교 연산자 역시 이항 연산자이므로 피연산자의 타입이 다르면 자동 형변환된 후 비교한다. 기본형과 참조형은 서로 형변환이 가능하지 않아 등가비교 연산자로 비교할 수 없다. 
- float과 double의 값을 비교할 때 float을 double로 변환하면 그저 가수 빈자리를 0으로 채울뿐이라 값의 변화가 없다. 따라서 double을 float으로 형변환하면 어느정도 오차는 무시하고 앞에서 몇자리를 잘라 비교할 수 있다.
- 문자열을 비교할 때는 ==가 아닌 equals()를 사용한다. 대소문자 구별없이 비교하고 싶다면 equalsIgnoreCase()를 사용한다.
- 논리 연산자 사용 시 OR 연산의 경우 연산결과가 참일 확률이 높은 피연산자를 연산자의 왼쪽에 놓으면 더 빠른 연산결과를 얻을 수 있다.
- ~는 비트 전환 연산자로 피연산자의 1의 보수를 얻을 수 있다.
- **>>** 연산자의 경우 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 음수인 경우 1로 빈자리를 채운다.
- x **<<** n은 x * 2ⁿ의 결과와 같고 x **>>** n은 x / 2ⁿ의 결과와 같다. 곱셈이나 나눗셈보다 연산속도가 빠르다. 
- 삼항 연산자에서 조건 연산자의 식1과 식2두 피연산자의 타입이 다른 경우 이항 연산자처럼 산술 변환이 일어난다.



## Chapter 04 조건문과 반복문

- 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 **제어문**이라고 한다. 제어문에는 조건문, 반복문이 있다.

### 1. 조건문 - if, switch

- switch문: if문과 달리 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현도 간결하다. break문이 각 case문의 영역을 구분하는데 생략하면 case문 사이의 구분이 없어져 다른 break문을 만나거나 switch 블럭 끝까지 모든 문장을 수행한다.
  - 조건식의 결과값은 반드시 정수여야 한다. 그러나 JDK 1.7부터 문자열 허용
  - case문의 값 역시 정수여야 하고 중복되면 안된다. JDK 1.7부터 문자열 허용
  - case문의 값은 반드시 상수여야한다. 변수, 실수, 문자열은 불가능하다.
  - if와 else if를 사용해 여러번의 조건식을 계산해야할 때와 달리 조건식을 1번만 계산해도 되어 빠르다.

```java
switch (조건식) {
    case 값1 :
        
        break;
    case 값2 :
        
        break;
    default:
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}


// 일부러 break문을 생략하는 경우. 회원제 웹사이트에서 많이 사용될 만한 코드다.
switch (level) {
    case 3 :
        grantDelete();  // 삭제 권한 부여
    case 2 :
        grantWrite();   // 쓰기 권한 부여
    case 1 :
        grantRead();    // 읽기 권한 부여
    default:
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}

// break문 생략하는 경우2
switch (month) {
    case 3 :
    case 4:
    case 5:
        System.out.println("봄");
    case 6 : case 7: case 8:
        System.out.println("여름");
    case 9 : case 10: case 11:
        System.out.println("가을");
    default:
        System.out.println("겨울");
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}
```

- 문자열.charAt(index)로 문자열에 저장된 문자를 가져올 수 있다.



### 2. 반복문 - for, while, do-while

#### 2.1 for문

- 초기화: 보통 변수 하나로 제어하지만 둘 이상이 필요할 경우 콤마를 구분자로 변수를 초기화 한다. 단, 두 변수의 타입이 같아야 한다.
- 증감식: 초기화처럼 콤마를 사용해 두 문장 이상을 하나로 연결해 쓸 수 있다.
- 초기화, 조건식, 증감식은 필요없으면 생략할 수 있고 모두 생략도 가능하다. 조건식이 생략되면 참으로 간주되어 무한 반복이 일어난다. 
- 향상된 for문: JDK 1.5부터 배열, 컬렉션에 저장된 요소에 접근할 떄 기존보다 편리하게 처리할 수 있도록 새로운 문법이 추가되었다.

```java
for (타입 변수명: 배열 또는 컬렉션) {
    // ...
}
```

#### 2.2 while문

- for문과 달리 while문의 조건식은 생략할 수 없다.

#### 2.6 이름 붙은 반복문

- break문은 근접한 단 하나의 반복문만 벗어날 수 있어 여러 개의 반복문이 중첩된 경우에는 완전히 벗어날 수 없다. 이 때는 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다. 

```java
Loop1: for(int i=2; i <= 9; i++) {
    for (int j=1; j <= 9; j++) {
        if (j==5)
            break Loop1;
        //	break;
        //	continue Loop1;
        //	continue;
        
    }
}

// while문에서 사용
outer:
while(true) {
    //
    if (//) {
        break outer;
        }
}
```



## Chapter 05 배열

### 1. 배열(array)

#### 1.1 배열(array)이란?

- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것
- 배열의 변수는 배열을 다룰 때 필요한 참조변수로 값을 저장하는 공간은 아니다.
- 변수와 달리 배열은 각 저장공간이 연속적으로 배치되어 있다.
- 배열의 선언은 배열을 다루기 위한 참조변수의 공간이 만들어지는 것이고 new와 함께 배열 타입과 길이를 지정해주는 **생성**을 해야만 비로소 값을 저장할 수 있는 공간이 만들어진다.
- 유효 범위를 벗어난 값을 index로 사용하는 실수를 컴파일러가 걸러줄 수 없는 이유: 배열 index로 변수를 많이 사용하는데 변수의 값은 실행 시에 대입되므로 컴파일러는 이 값의 범위를 확인할 수 없다.
- **길이가 0인 배열도 생성할 수 있다.**
- 배열은 한번 생성하면 길이를 변경할 수 없기 때문에 배열이름.length는 상수다.
- 배열 생성과 동시에 자신 타입에 따른 기본값으로 초기화되지만 원하는 요소로 초기화할 수도 있다. 

```java
// new int[]는 생략가능하다. 하지만 배열의 선언과 생성을 따로 하는 경우에는 new int[]를 생략할 수 없다.
int[] score = new int[]{50, 60, 70, 80, 90};

// {} 안에 아무것도 넣지 않으면 길이가 0인 배열이 생성된다. 셋 다 길이가 0인 배열이다.
int[] score = new int[0];
int[] score = new int[]{};
int[] score = {}:
```

- 배열 안의 요소를 확인하기 위해 for문을 사용하는 대신 Arrays.toString(배열이름) 메서드를 사용할 수 있다.
- 배열 변수를 바로 출력하면 타입@주소 형식으로 출력되지만 **char배열은 각 요소가 구분자 없이 그대로 출력된다.**
- 배열을 복사하기 위해서 기존 배열의 2배 길인 배열 생성 -> 기존 배열의 값을 새로운 배열에 저장 -> 기존 배열이 새로운 배열을 가리키게 해야한다.
  - 기존 배열과 새로운 배열은 이름만 다를뿐 동일한 배열이다.
  - 배열은 참조변수를 통해서만 접근할 수 있기 때문에 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없다. 이렇게 쓸모없게 된 배열은 JVM의 가비지 컬렉터에 의해 자동적으로 메모리에서 제거된다.
  - for문 대신 값을 하나씩 다시 저장하지 않고 System클래스의 arraycopy()를 사용하면 간단하고 빠르게 복사할 수 있다. arraycopy()는 지정된 범위 값들을 한 번에 통째로 복사한다. 각 요소들이 연속적으로 저장되어 있다는 특성 덕분에 가능하다.
  - System.arraycopy(기존배열이름, 기존배열 복사 시작 위치, 새 배열 이름, 새 배열 복사 시작 위치, 복사할 요소 수)



### 2. String 배열

- String 배열 생성시 참조형 변수 기본값은 null이므로 각 요소는 null로 초기화된다. 또한 참조형 배열의 경우에는 배열에 저장되는 것은 객체의 주소다. 참조형 배열을 객체 배열이라고도 한다.
- String 클래스는 char 배열에 기능(메서드)을 추가한 것이다. 
- 객체지향 기념이 나오기 전의 언어는 데이터와 기능을 따로 두었으나 객체지향언어에서는 데이터와 그와 관련된 기능을 하나의 클래스에 묶어서 다룰 수 있게 한다.
- char배여로가 String클래스의 중요한 차이는 String객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다는 것이다. 문자열을 변경하는 것처럼 보이지만 새로운 내용의 문자열이 생성되는 것이다.
- String클래스의 주요 메서드
  - charAt(int index): 해당 위치의 문자 반환
  - substring(int from, int to): 해당범위의 문자열 반환(to는 포함되지 않는다.)
  - toCharArray(): 문자열을 문자배열로 변환해서 반환 / 문자배열(char 배열)을 String클래스로 변환하는 메서드는 new String(char배열)을 사용
- Scanner클래스로 값을 입력받는 것 외에 **커맨드라인**을 사용해 프로그램 실행 시 클래스 이름 뒤 공백문자로 구분해 여러 문자열을 전달할 수 있다.
  - 공백문자로 매개변수를 구분하기 때문에 입력될 값에 공백이 있는 경우 큰따옴표로 감싸야한다.
  - 숫자를 입력해도 문자열로 처리된다.
  - 배열 생성하지 않으면 참조변수 args가 null이 되어 사용하는 코드에서 에러가 발생하지만 JVM이 null대신 크기가 0인 배열을 생성해 args에 전달하도록 구현한다.



### 3. 다차원 배열

- 선언 방법은 1차원 배열과 같다. 타입[] 변수이름[]으로 써도 2차원 배열로 선언이 된다.
- 1차원 배열과 마찬가지로 {}를 사용해 생성과 초기화를 동시에 할 수 있다. 

```java
// 행별로 줄바꿈을 하면서 초기화하면 더 이해하기 쉽다.
int[][] data = {
    {1, 2, 3},
    {4, 5, 6}
}
```

- 가변배열: 마지막 차수의 길이를 지정하지 않고 추후 각기 다른 길이 배열을 생성할 수 있다.

```java
int[][] data = new int[3][];
data[0] = new int[3];
data[1] = new int[4];
data[2] = new int[10];
```



## Chapter 06 객체지향 프로그래밍 I

### 1. 객체지향언어

- 객체지향이론: 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다. 실제 사물의 속성과 기능을 분석한 후 데이터(변수)와 함수로 정의
  - 주요 특징: 코드의 재사용성 높음 / 코드 관리 용이 / 신뢰성 높은 프로그래밍(제어자, 메서드를 이용해 데이터를 보호하고 올바른 값 유지. **중복을 제거**해 코드 불일치로 인한 오동작 방지)

### 2. 클래스와 객체

- 클래스: 객체를 정의해놓은 것. 객체의 설계도 또는 툴. 클래스는 객체를 생성하는데 사용하며 객체는 클래스에 정의된 대로 생성된다. 개념이나 논리같은 무형적인 것들도 객체로 간주한다. 하나의 설계도만 잘 만들어두면 제품을 만드는 일은 쉬워진다.
- 클래스로부터 객체를 만드는 과정: 인스턴스화 / 만들어진 객체: 인스턴스
- 객체는 **속성**과 **기능**, 두 종류 구성요소로 이루어진다. 객체는 다수의 속성과 다수의 기능을 가진다. 그리고 그 객체가 가진 속성, 기능을 객체의 **멤버**라고 한다. 속성보다는 **멤버변수**, 기능보다는 **메서드**라고 표현한다.
- 인스턴스의 생성

```java
Tv t;             // Tv클래스 타입의 참조변수 t선언
t = new Tv();     // Tv 인스턴스 생성 후, 생성된 인스턴스 주소를 t에 저장
```

- 객체 배열: 객체를 생성해서 객체 배열의 각 요소에 저장하는 것을 잊지 말기.

```java
Tv[] tvArr = new Tv[3];
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 또는
TV[] tvArr = { new Tv(), new Tv(), new Tv() };
```

- 데이터 저장형태의 발전과정
  1. 변수: 하나의 데이터를 저장할 수 있는 공간
  2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
  3. 구조체: 서로 관련된 여러 데이터를 종류 관계없이 하나의 집합으로 저장할 수 있는 공간
  4. 클래스: 데이터와 함수의 결합(구조체 + 함수)



### 3. 변수와 메서드

- 변수는 클래스변수, 인스턴스변수, 지역변수 세 가지가 있다. 종류를 결정짓는 것은 **선언된 위치**다. 멤버변수를 제외한 변수는 모두 지역변수고 멤버변수에서 static이 붙은 것은 클래스변수, 붙지 않은 것은 인스턴스변수다.

```java
class Variables
{
    int iv;          // 인스턴스변수
    static int cv;   // 클래스변수
    
    void method() {
        int lv = 0;  // 지역변수
    }
}
```

- 인스턴스 변수: 클래스 영역에 저장되며 클래스 인스턴스를 생성할 때 만들어진다. 인스턴스 변수의 값을 읽거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다. 인스턴스마다 고유한 상태를 유지해야하는 속성이면 인스턴스변수로 선언한다.
- 클래스 변수: 인스턴스 변수 앞에 static을 붙이면 된다. 모든 인스턴스 변수가 공통된 저장공간을 공유한다. 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다는 특징이 있으며 **클래스이름.클래스변수**와 같은 형식으로 사용한다. 클래스가 메모리에 로딩될 때(올라갈 때) 생성되어 프로그램 종료시까지 유지된다. public을 붙이면 같은 프로그램 내 어디서나 접근 가능한 **전역변수**의 성격을 가진다. 인스턴스이름.클래스변수로 접근해 값을 바꿔도 인스턴스끼리 모두 같은 값을 공유하게 되지만 클래스 이름으로 접근하는 것이 좋다.
- 지역변수: 메서드 내에 선언되어 메서드 내에서만 사용가능해 메서드가 종료되면 소멸한다. 

- 메서드: 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것. 내부가 보이지 않는 블랙박스다. 높은 재사용성, 중복된 코드 제거, 프로그램의 구조화라는 장점을 가진다.
  - 선언부와 구현부로 이루어진다. 
  - 선언부에서 매개변수 선언할 값이 너무 많다면 배열이나 참조변수를 사용하면 된다.
  - 메서드를 호출할 때 괄호 안에 지정해준 값들을 **인자(argument)** 또는 **인수**라고 한다. 
  - 같은 클래스 내의 메서드끼리는 참조변수 사용없이 호출 가능하지만 static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.
  - 반환갑의 유무에 관계없이 모든 메서드는 적어도 하나의 return문이 있어야 한다. 다만 반환타입이 void인 경우 return문이 없으면 컴파일러가 메서드의 마지막에 return;을 자동적으로 추가해주어서 오류가 발생하지 않았다.
  - 메서드 구현부 작성할 때 가장 먼저 해야 하는 일은 매개변수 값이 적절한지 확인하는 것이다. 예를 들어 나누기 메서드를 만들 때는 나누는 값이 0이 아닌지 미리 **유효성 검사**가 필요하다. 



#### 3.7 JVM의 메모리 구조

- 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
- 3가지 주요 영역
  - 메서드 영역(method area): 어떤 클래스가 사용되면 해당 클래스의 클래스파일(*.class)을 읽어서 분석해 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 클래스 변수도 이 영역에 함께 생성된다.
  - 힙(heap): 인스턴스가 생성되는 공간. 인스턴스 변수들도 생성된다.
  - 호출스택(call stack): 메서드가 호출되면 작업에 필요한 메모리 공간 제공. 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과를 저장한다. 작업을 마치면 할당됐던 메모리 공간은 반환되어 비워진다. 각 메서드를 위한 메모리상의 작업공간은 서로 구별된다. 처음 호출된 메서드를 위한 작업공간이 호출 스택 맨 밑에 마련되고 수행 중 다른 메서드를 호출하면 바로 위에 두 번째 메서드를 위한 공간이 마련된다. 이 때 첫 번째 메서드는 수행을 멈추고 두 번째 메서드가 수행되기 시작한다. 두 번째 메서드 작업이 끝나면 메모리 공간이 반환되고 다시 첫 번째 메서드를 수행하게 된다. 호출 스택의 가장 상위의 메서드가 현재 실행 중인 메서드이며 나머지는 대기상태에 있는다.
- 객체를 생성하지 않고 메서드를 호출하려면 메서드 앞에 static을 붙여야 한다.
- 기본형 매개변수와 참조형 매개변수: 메서드 호출 시 매개변수로 지정한 값을 메서드 매개변수에 복사해서 넘겨준다. 기본형일 때는 값이 복사되지만 참조형이면 인스턴스 주소가 복사된다. 따라서 참조형일 경우 저장된 곳의 주소를 알 수 있어 값을 읽어 오는 것은 물론 변경하는 것도 가능하다. 
- 반환타입이 참조형이면 메서드가 객체의 주소를 반환한다는 것이다.



#### 3.10 재귀호출(recursive call)

- 값에 의한 호출로 원래 값이 아닌 복사된 값으로 작업하기 때문에 호출된 메서드 관계없이 독립적인 작업수행이 가능하다.
- 재귀호출로 작성하면 다소 비효율적이라도 알아보기 쉬워 논리적 오류가 발생할 가능성도 줄어들고 수정하기 좋다.



#### 3.11 클래스 메서드(static 메서드)와 인스턴스 메서드

- 클래스 변수(static 변수), 인스턴스 변수 모드 멤버변수로 클래스 영역에 선언된 변수다. 
- 변수처럼 메서드 앞에 static이 붙어 있으면 클래스 메서드고 아니면 인스턴스 메서드다.
- 클래스 메서드도 클래스 변수처럼 객체를 생서하지 않고도 클래스이름.메서드이름으로 호출이 가능하다. 반면 인스턴스 메서드는 반드시 객체를 생성해야 호출할 수 있다.
- 클래스는 데이터(변수)와 데이터와 관련된 메서드의 집합이므로 같은 클래스 내의 메서드와 멤버변수는 아주 밀접한 관계가 있다.
- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 해 메서드 작업 수행에 인스턴스 변수가 필요하다. 
- 반면 인스턴스와 관계없는(인스턴스 변수, 인스턴스 메서드 사용하지 않는) 메서드를 클래스 메서드(static 메서드)로 정의한다.

1. 클래스를 설계할 때 멤버변수 중 모든 인스턴스에서 같은 값을 유지하는 변수는 static을 붙여 클래스 변수로 정의한다.
2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다. 클래스가 메모리에 올라갈 때 자동적으로 생성되기 때문이다.
3. 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다. 반면 인스턴스 변수, 메서드는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재하면 static 변수는 이미 메모리에 존재하기 때문이다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않으면 static을 붙인다. 메서드 호출 시간이 짧아져 성능이 향상된다. 인스턴스 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요해 시간이 더 걸린다.



### 4. 오버로딩(overloading)

- 한 클래스 내에 사용하려는 이름과 같은 이름을 가진 메서드가 있어도 **매개변수의 개수** 또는 **타입**이 다르면 같은 이름으로 정의할 수 있다. 이를 오버로딩이라고 한다. 매개변수에 의하서만 구분되며 반환 타입은 오버로딩 구현에 영향을 주지 못한다.
- 기존에는 메서드 매개변수 개수가 고정적이었으나 JDK 1.5부터 동적으로 지정해 줄 수 있게 되었다. 이 기능을 **가변인자(variable arguments)**라고 한다. **타입... 변수명**같은 형식으로 선언한다. 가변인자는 매개변수 중 가장 마지막에 선언하지 않으면 컴파일 에러가 발생한다. 인자 없어도 되고 해당 타입의 배열을 넘겨주는 것도 가능하다. 가변인자는 **내부적으로 배열을 이용**하기 때문이다. 하지만 매개변수 타입을 배열로 지정해줄 경우 인자가 없으면 에러가 발생한다. 따라서 null이라도 넘겨야한다. 주의할 점은 가변인자를 선언 메서드를 오버로딩하면 구별되지 못하는 경우가 발생하므로 하지 오버로딩하지 않는 것이 좋다.



### 5. 생성자(Constructor)

- 인스턴스가 생성될 때 호출되는 **인스턴스 초기화 메서드**(인스턴스 변수들을 초기화). 메서드처럼 클래스 내에 선언되지만 리턴값이 없다는 점이 다르다. 생성자의 조건은 이름이 클래스 이름과 같아야 하며 리턴값이 없다는 것이다. 생성자 역시 오버로딩이 가능하다. 인스턴스 생성은 연산자 **new**로 하는 것이지 생성자가 인스턴스를 생성하는게 아니다.  
- 클래스에 생성자가 없으면 컴파일러가 매개변수, 내용이 없는 기본 생성자를 제공한다.
- 생성자 간 호출: 생성자 이름 대신 **this**사용, 반드시 **첫 줄**에서만 호출 가능. 생성자 내에서 초기화 작업도중에 다른 생성자를 호출하게 되면 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것 이므로 이전 작업이 무의미해질 수 있기 때문이다. 

```java
class Car{
    String color;
    String gearType;
    int door;
    
    Car() {
        this("white", "auto", 4);
    }
    
    // 생성자 매개변수 이름이 인스턴스 변수 이름과 같아 구별이 안된다. 이런 경우 인스턴스 변수 앞에 this를 사용한다. 생성자 매개변수로 인스턴스변수들의 초기값을 받는 경우가 많아 일치할 때가 많다.
    // this는 참조변수로 인스턴스 자신을 가리키고 이를 사용해 인스턴스변수에 접근할 수 있다. 인스턴스멤버만 this를 사용할 수 있고 static 메서드에서는 불가능하다. 
    // 생성자 포함 모든 인스턴스 메서드는 자신이 관련된 인스턴스를 가리키는 참조변수 this가 지역변수로 숨겨진채 존재한다.
    Car(String color, String gearType, int door) {
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}
```

- this: 인스턴스 자신을 가리는 참조변수로 인스턴스 주소가 저장되어 있다.
- this(), this(매개변수): 생성자. 같은 클래스 다른 생성자를 호출할 때 사용
- 생성자를 이용해 인스턴스를 복사하기 위해 인스턴스를 매개변수로 받는 생성자를 만들 수 있다. 또는 Object 클래스의 clone메서드를 이용할 수도 있다.



### 6. 변수의 초기화

- 변수를 선언하고 처음으로 값을 저장하는 것. 선언과 동시에 적절한 값으로 초기화하는 게 바람직하다.
- 멤버변수는 초기화하지 않아도 자료형에 맞는 기본값으로 초기화되므로 초기화하지 않고 사용해도 되지만 지역변수는 사용하기 전에 반드시 초기화해야 한다. 
- 멤버변수의 초기화 방법: 명시적 초기화, 생성자, 초기화 블럭
  - 명시적 초기화: 선언과 동시에 초기화
  - 초기화 블럭: 클래스 변수의 복잡한 초기화에 사용하는 **클래스 초기화 블럭**과 인스턴스변수의 복잡한 초기화에 사용되는 **인스턴스 초기화 블럭**이 있다.  인스턴스 초기화 블럭은 단순히 클래스 내에 블럭을 만들고 그 안에 코드를 작성하며 클래스 초기화 블럭은 인스턴스 초기화 블럭 안에 static을 덧붙이면 된다. 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다. 인스턴스 변수 초기화는 주로 생성자를 사용하며 **모든 생성자에서 공통적으로 수행돼야 하는 코드**를 넣을 때 인스턴스 초기화 블럭을 이용한다.

```java
class Car{
    String color;
    String gearType;
    int serialNo;
    
    // 인스턴스 초기화 블럭. 중복을 제거해 코드의 신뢰성을 높이고 오류 발생 가능성을 줄인다. 객체 지향 프로그래밍의 목표
    {
        count++;
        serialNo = count;
    }
    
    Car() {
        color = white;
        gearType = "Auto";
    }
    
    Car(String color, String gearType) {
        this.color = color;
        this.gearType = gearType;
    }
}
```

- 클래스변수 초기화순서: 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
- 인스턴스변수 초기화순서: 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자



## Chapter 07 객체지향 프로그래밍 II

### 1. 상속(inheritance)

- 기존 클래스를 재사용해 새로운 클래스 작성. 보다 적은 양의 코드로 새로운 클래스 작성. 코드를 공통적으로 관리해 코드 추가 및 변경 매우 용이. **재사용성**, **중복 제거**
- 조상 클래스 = 부모, 상위(super), 기반(base) 클래스
- 자손 클래스 = 자식, 하위(sub), 파생된(derived) 클래스
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받는다. 생성자, 초기화 블럭은 상속받지 않는다. 
- 포함관계: 상속 외에 클래스를 재사용하는 방법이다. 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다. 하나의 거대한 클래스를 작성하기 보다 단위별로 여러 개의 클래스를 작성하고 포함관계로 재사용하면 간결하고 손쉽다. 
- 상속관계를 맺어줄 것인지 포함관계를 맺어줄 것인지 헷갈린다면 ~은 ~이다와 ~은 ~을 가지고 있다를 넣어서 문장을 만들어보자.
- 클래스에 작성된 toString(): 인스턴스 정보를 문자열로 반환할 목적으로 정의됨. 참조변수의 출력이나 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리한다. 모든 클래스의 조상인 **Object 클래스**에 정의된 것으로, 어떤 종류의 객체에 대해서도 toString() 호출이 가능하다. 
- 자바는 다중상속이 불가능하므로 다음과 같이 사용할 수 있다. 조상은 Tv 클래스고 VCR클래스는 TVCR 클래스에 포함시켰다. 외부적으로 TVCR클래스의 인스턴스를 사용하는 것처럼 보이지만 내부적으로 VCR 클래스의 인스턴스를 생성해 사용하는 것이다.

```java
class Tv {
    boolean power;
    int channel;
    
    void power() { power = !power; }
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
}

class VCR {
    boolean power;
    int counter = 0;
    void power() {}
    void play() {}
    void stop() {}
    void rew() {}
    void ff() {}
}

class TVCR extends TV {
    VCR vcr = new VCR();
    void play() {
        vcr.play();
    }
    
    void stop() {
        vcr.stop();
    }
    
    void rew() {
        vcr.rew();
    }
    
    voic ff() {
        vcr.ff();
    }
}
```

- Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스다. 다른 클래스로부터 상속받지 않는 모든 클래스는 자동적으로 Object 클래스로부터 상속받게 한다. 컴파일러가 자동적으로 extends Object를 추가한다. 따라서 모든 클래스의 조상은 Object가 되고 toStrigng()이나 equals(Object o)와 같은 메서드를 따로 정의하지 않고 사용할 수 있었다.



### 2. 오버라이딩(overriding)

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 오버라이딩의 조건: 선언부가 조상의 것과 완전히 일치해야 한다. (이름, 매개변수, 반환타입) 그러나 JDK 1.5부터 공변 반환타입이 추가되어 반환타입을 자손 클래스 타입으로 변경하는 것은 가능하도록 완화되었다. 
  - 접근 제어자는 조상 클래스 메서드보다 좁은 범위로 변경할 수 없다.
  - 조상 클래스 메서드보다 많은 수의 예외를 선언할 수 없다. 그러나 자손클래스에서 throws Exception 하나만 선언한다해도 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던지도록 선언한 것이므로 잘못된 오버라이딩이다.
  - 인스턴스 메서드를 static으로, 또는 그 반대로 변경할 수 없다.
  - 조상 클래스의 static 메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의할 수 있지만 각 클래스에 별개의 static 메서드를 작성한 것일 뿐 오버라이딩이 아니다. 각 메서드는 클래스 이름으로 구별될 수 있고 호출 할때 참조변수.메서드이름 대신 클래스이름.메서드이름이 바람직하다. static 멤버들은 자신들이 정의된 클래스에 묶여있다.
- super: 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수. 멤버변수, 지역변수 이름이 같을 때 this를 붙여서 구별했듯이 super를 사용한다. 조상 클래스로부터 상속 받은 멤버도 자손 클래의 멤버이므로 this를 사용할 수도 있다. 조상, 자손 클래스 멤버가 중복 정의되어 서로 구별해야하는 경우에만 super를 사용하면 좋다. static메서드(클래스 메서드)는 인스턴스와 관련이 없기 때문에 this와 마찬가지로 super도 static 메서드에서 사용할 수 없고 인스턴스 메서드에서만 사용할 수 있다. 조상 클래스 메서드 내용에 추가적으로 작업을 덧붙이는 경우에 super를 사용해 포함시키면 좋다. 조상 클래스 메서드가 변경되면 반영할 수 있기 때문이다.
- super(): 조상 클래스의 생성자
  - this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만 super()는 조상 클래스의 생성자를 호출하는데 사용된다.
  - 자손 클래스 인스턴스 생성하면 조상 클래스 멤버들도 사용가능하다. 이 때 조상 클래스 멤버를 사용할 수 있게 초기화 작업이 먼저 수행되어야 하므로 자손 클래스 생성자에서 조상 클래스 생성자가 호출되어야 한다. Object 클래스를 제외한 모든 클래스 생성자는 첫 줄에 반드시 **자신의 다른 생성자** 또는 **조상의 생성자**를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 자동적으로 추가한다. 만약 상속받은 클래스가 둘 중 하나를 호출하지 않아서 super()가 자동적으로 생성되면 매개변수를 주지 않는 조상 클래스 기본 생성자가 호출된다. 이 때 조상 클래스에 해당 생성자가 에러가 발생한다.



### 3. package와 import

- 패키지: 클래스의 묶음. 클래스 또는 인터페이스를 포함시킬 수 있다. 관련된 클래스들끼리 그룹 단위로 묶어 놓아 효율적으로 관리한다. 같은 이름 클래스여도 서로 다른 패키지에 존재하는게 가능하다. 예를들어 java.lang.String 클래스는 java의 서브 디렉토리인 lang에 속한 String.class파일로 rt.jar파일에 압축되어있다.
  - 클래스 파일들을 압축한 것이 jar파일(*.jar)이다.
  - 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
  - 모든 클래스는 하나의 패키지에 속해야 한다. (지금까지 문제가 없었던 이유는 자바에서 이름없는 패키지-unnamed package를 기본적으로 제공하기 때문이다.)
  - 패키지는 점을 구분자로 하여 계층구조로 구성할 수 있다.
  - 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리다.
- 패키지 선언은 클래스나 인터페이스 소스파일(.java)의 맨 위에 package 패키지명; 만 적어주면 된다. 해당 문장은 주석과 공백을 제외한 첫 번째 문장이어야 하며, 하나의 소스파일에 단 한번만 선언될 수 있다. 패키지명은 대문자도 가능하지만 클래스명과 구분짓기 위해 **소문자로 하는 것을 원칙**으로 한다.
- 클래스 작성후 -d 옵션을 추가해 컴파일한다. -d옵션은 소스파일에 지정된 경로를 통해 패키지 위치를 찾아 클래스 파일을 생성한다. 패키지와 일치하는 디렉토리가 없으면 생성한다. -d옵션 뒤에는 해당 패키지의 루트 디렉토리 경로를 적어주는데 .은 현재 디럭토리를 의미하기 때문에 컴파일을 수행하면 C:\jdk1.8\work에 패키지명에 적어준데로 디렉토리가 생성된다.

```
C:\jdk1.8\work>javac -d . PackageTest.java
```

- 생성된 패키지의 루트 디렉토리를 클래스패스(classpath, 컴파일러(javac.exe)나 JVM 등이 클래스의 위치를 찾는데 사용되는 경로)에 포함시켜야 한다. 루트 디렉토리를 클래스패스에 포함시켜야하만 실행 시 JVM이 PackageTest 클래스를 찾을 수 있다. 
  - 제어판-시스템-고급 시스템 설정-환경 변수-새로만들기에서 변수 CLASSPATH를 입력하고 변수 값에 .;C:\jdk1.8\work를 입력한다. ;를 구분자로 여러 경로를 클래스패스에 지정할 수 있고 맨 앞의 .;를 추가해 현재 디렉토리를 포함시킨다. 클래스패스를 지정하지 않으면 자동으로 현재 디렉토리가 지정되지만 따로 지정해준 경우에는 자동으로 지정되지 않아 추가해야 한다.
  - jar파일을 클래스패스에 추가하기 위해서는 경로와 파일명까지 적어줘야 한다. 
- 예제 실행: PackageTest클래스의 패키지명을 모두 적어줘야한다.

```
C:\WINDOWS>java com.codechobo.book.PackageTest
```

- JDK의 기본 클래스패스를 이용하면 예제에서처럼 클래스패스를 따로 설정하지 않아도 된다. 새로 추가하려는 클래스를 JDK설치디렉토리\jre\classes 디렉토리에, jar파일이면 JDK설치디렉토리\jre\lib\ext 디렉토리에 넣으면된다.(jre의 classes디렉토리는 자동으로 생성되지 않으므로 직접 생성한다.)
- 또는 실행시에 -cp옵션으로 일시적으로 클래스패스를 지정해줄 수 있다.

```
C:\WINDOWS>java -cp c:\jdk1.8\work com.codechobo.book.PackageTest
```



- import문을 사용하면 사용하려는 클래스의 패키지를 미리 명시해줘 소스코드에 사용되는 클래스 이름에서 패키지명을 생략할 수 있다. 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공한다. 컴파일 시 컴파일러가 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아내 모든 클래스 이름 앞에 패키지명을 붙여 준다. 
- 소스파일(*.java) 구성 순서: package문 - import문 - 클래스 선언
- import문에서 클래스 이름 대신 *을 사용하는 것이 하위 패키지 클래스까지 포함하지는 않는다.
- java.lang패키지는 매우 빈번히 사용되므로 묵시적으로 import되어있다.
- static import문을 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```java
import static java.lang.Math.random;
import static java.lang.System.out;

out.println(random());
```



### 4. 제어자(modifier)

- 클래스, 변수, 메서드 선언부에 함께 사용되어 부가적 의미 부여. 하나의 대상에 여러 제어자를 조합해 사용하는게 가능하지만 접근 제어자는 넷 중 하나만 선택해야 한다. 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다. 크게 접근 제어자와 그 외 제어자로 나뉜다.
  - 접근 제어자: public, protected, default, private
  - 그 외: static, final, abstract, native, transient, synchronized, vloatile, strictfp



#### 4.2 static - 클래스의, 공통적인

- 멤버변수, 메서드, 초기화 블럭에서 사용된다.
- 멤버변수: 모든 인스턴스에 공통적으로 사용되는 클래스 변수 / 인스턴스 생성하지 않고도 사용 가능 / 클래스가 메모리에 로드될 때 생성
- 메서드: 인스턴스 생성하지 않고도 호출 가능 / static메서드 내에서 인스턴스 멤버들 직접 사용 불가능 / 인스턴스 멤버 사용하지 않으면 편하고 속도가 빠르도록 static메서드로 선언하자



#### 4.3 final - 마지막의, 변경될 수 없는

- 클래스: 변경 불가능, 확장될 수 없으므로 조상이 될 수 없음
- 메서드: 변경 불가능, 오버라이딩으로 재정의 불가능
- 멤버변수 & 지역변수: 값을 변경할 수 없는 상수
- 원래 상수는 일반적으로 선언과 초기화를 동시에 하지만 인스턴스 변수라면 생성자에서 초기화 되도록 할 수 있다. 

```java
class Card {
    final int NUMBER;
    final String KIND;
    
    Card(String kind, int num) {
        KIND = kind;
        NUMBER = num;
    }
}
```



#### 4.4 abstract - 추상의 , 미완성의

- 클래스: 클래스 내에 추상 메서드가 선언되어 있음 의미 / 완성되지 않은 메서드가 존재하는 미완성 설계도이므로 인스턴스를 생성할 수 없다.
  - 추상 메서드가 없지만 abstract를 붙인 경우가 있다. 아무 내용이 없는 메서드만 존재해 인스턴스를 생성하지 못하게 했다. 다른 클래스가 이 클래스를 상속받아 일부의 원하는 메서드만 오버라이딩해도 된다는 장점을 가진다.
- 메서드: 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드 선언



#### 4.5 접근 제어자(access modifier)

- 클래스, 멤버변수, 메서드, 생성자
- private: 같은 클래스 내에서만 접근 가능
- default: 같은 패키지 내에서만 접근 가능
- protected: 같은 패키지 내에서, 다른 패키지 자손 클래스에서 접근 가능
- public: 접근 제한 없음
- 캡슐화: 접근 제어자를 사용하는 이유는 클래스 내부의 데이터를 보호하기 위해서다. 유효한 값을 유지하도록, 외부에서 함부로 변경하지 못하도록 제한하는 것이 필요하다. 이것을 **데이터 감추기**라고 하며 **객체지향개념의 캡슐화**에 해당한다. 또 다른 이유는 클래스 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 위한 메서드같은 멤버를 클래스 내부에 감추기 위해서다. 외부에서 접근할 필요가 없는 멤버들을 private으로 지정해 노출시키지 않고 복잡성을 줄인다.
  - 만약 메서드 하나를 변경한다면 접근 제어자가 public이면 변경 후 오류가 없는지 테스트해야할 범위가 넓다. 하지만 접근 제어자 범위에 따라 줄일 수 있으므로 접근 제어자를 적절히 선택하자.
  - 클래스에 public 멤버변수가 존재하면 인스턴스를 생성 후 직접 접근해 값을 변경할 수 있다. 하지만 이 경우 값의 유효성 검사를 할 수 없다. 따라서 private이나 protected로 제한하고 멤버변수 값을 읽거나 변경하는 public 메서드를 제공하는게 바람직하다. 이를 getter, setter라고 한다. 
  - 상속을 통해 확장될 것이 예상되는 클래스라면 멤버에 접근 제한을 주되 자손 클래스에서 접근 가능하도록 protected를 사용한다.
- 하나의 소스파일(*.java)에는 public 클래스가 단 하나만 존재할 수 있으며 소스파일 이름은 반드시 public 클래스의 이름과 같아야 한다.
- 생성자에 접근 제어자를 사용해 인스턴스 생성을 제한할 수 있다. 보통 생성자의 접근 제어자는 클래스 접근 제어자와 같지만 다르게 지정할 수도 있다. 생성자 접근 제어자가 private이면 내부에서만 인스턴스를 생성할 수 있다. 대신 인스턴스를 생성해서 반환해주는 public 메서드를 제공해 외부에서 이 클래스의 인스턴스를 사용할 수 있게 한다. 이 메서드는 public인 동시에 static이어야 한다.

```java
class Singleton {
    // getInstance에서 사용가능하도록 인스턴스를 미리 생성해야 하므로 static
    private static Singleton s = new Singleton(); 
    
    private Singleton() {
        
    }
    
    // 인스턴스 생성하지 않고도 호출할 수 있어야하므로 static
    public static Singleton getInstance() {
        return s;
    }
}
```

- 생성자가 private이면 조상이 될 수 없다. 자손클래스에서 호출이 불가능하기 때문에. 따라서 final을 추가해 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.
- 주의사항
  - 메서드에 static, abstract를 함께 사용할 수 없다. static메서드는 몸통이 있는 메서드에만 사용할 수 있다.
  - 클래스에 abstract와 final을 동시에 사용할 수 없다. 의미가 모순된다.
  - abstract메서드 접근 제어자가 private일 수 없다. abstract는 자손 클래스에서 구현해줘야 한다.
  - 메서드에 private, final을 같이 사용할 필요 없다. 하나만 써도 의미가 충분하다.



### 5. 다형성(polymorphism)

- 여러 가지 형태를 가질 수 있는 능력. 자바에서 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 했다. 상속과 깊은 관계가 있다. **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다.**

```java
// CaptionTv 클래스는 Tv 클래스를 상속받아 만든 클래스다.
Tv t = new CaptionTv();
```

- 하지만 t에서는 CaptionTv 인스턴스의 모든 멤버를 사용할 수 없다. 상속받은 Tv 클래스 멤버들만 사용할 수 있다.
- 자손타입 참조변수로 조상타입 인스턴스를 참조하는 것은 불가능하다. 실제 인스턴스인 Tv의 멤버 개수보다 참조변수가 사용할 수 있는 멤버 개수가 더 많기 때문이다. 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 적거나 같아야 한다.
- 참조변수의 형변환: 서로 상속관계에 있는 클래스사이에서만 가능. 조상의 조상으로도 가능하다. 따라서 모든 참조변수는 모든 클래스의 조상인 Object로 형변환이 가능하다.
  - 자손 -> 조상타입: 업캐스팅, 형변환 생략가능
  - 조상 -> 자손타입: 다운캐스팅, 형변환 생략불가
- Car 타입의 참조변수 c를 조상인 Object타입의 참조변수로 형변환 하는 것은 참조변수가 다룰 수 있는 멤버 개수가 실제 인스턴스가 갖고있는 멤버 개수보다 적을 것이 분명하므로 문제가 되지 않는다. 그래서 생략이 가능하다. 
- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니라 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다. 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절하는 것뿐이다.

```java
Car car = new Car();
Car car2 = null;
FireEngine fe = null;
// 에러가 발생한다. car는 Car의 인스턴스인데 조상타입의 인스턴스를 자손타입의 참조변수로 참조하는 것은 허용되지 않는다. 
fe = (FireEngine)car;
```

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 **instance of** 연산자를 사용한다. 왼쪽에 참조변수, 오른쪽에 타입(클래스명)이 피연산자로 위치한다. 그리고 연산 결과로 boolean을 반환한다. true를 얻으면 참조변수가 검사한 타입으로 **형변환이 가능하다는 뜻**
- 자손 클래스에서 만든 인스턴스는 조상 클래스들의 인스턴스를 모두 포함하고 있기 때문에 instance of로 확인하면 true이다.
- 참조변수.getClass().getName(): 참조변수가 가리키고 있는 인스턴스의 클래스 이름을 문자열로 반환
- 조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스 변수를 자손 클래스에 정의했을 경우 참조변수 타입에 따라 다른 결과를 얻는다. 하지만 메서드의 경우 참조변수 타입에 관계없이 실제 인스턴스 메서드가 호출된다.
- 매개변수의 다형성: 원래는 buy의 매개변수로 Tv, Computer, Audio의 인스턴스가 각각 오게 따로 만들어줘야했지만 Product 클래스의 자손타입 참조변수면 어느 것이나 매개변수로 받아들일 수 있게 했다. 이처럼 print는 Object를 매개변수로 하고 있어 어떤 타입의 인스턴스도 처리할 수 있다.

```java
class Product {
    int price;
    int bonusPoint;
}
class Tv extends Product {}
class Computer extends Product {}
class Audio extends Product {}

class Buyer {
    int money = 1000;
    int bonusPoint = 0;
    
    void buy(Product p) {
        moeny = money = p.price;
        bonusPoint = bonusPoint + p.bonusPoint;
    }
}
```



- 조상타입 참조변수로 자손타입 객체를 참조하는 것이 가능하므로 조상타입 참조변수 배열을 사용해 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.

```java
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```



- Vector 클래스: 내부적으로 Object 타입의 배열을 가지고 있어 이 배열에 객체를 추가하거나 제거할 수 있다. 배열의 크기를 알아서 관리해줘 저장할 인스턴스 개수를 신경쓰지 않아도 된다. **동적으로 크기가 관리되는 객체배열**



### 6. 추상클래스(abstract class)

- 미완성 메서드(추상메서드)를 포함하고 있는 미완성 설계도. 키워드 abstract를 붙이면 된다. 상속을 통해 구현해줘야 함. 인스턴스를 만들지 못할 뿐 생성자, 멤버변수, 메서드를 가질 수 있다. 추상 메서드가 없어도 키워드를 붙여 추상 클래스로 만들 수 있다.
- 추상메서드(abstract method): 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것. 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만 작성하고 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성됐는지 알려주고 실제 내용은 상속받는 클래스에서 구현한다. 추상메서드 역시 키워드 abstract를 붙이고 구현부가 없으므로 {} 대신 ;를 적는다. 자손 클래스는 추상 메서드를 모두 구현해줘야 한다. 하나라도 구현하지 않으면 자손 클래스 역시 추상클래스로 지정해야 한다. 
- 추상화: 클래스간 공통점을 찾아 공통의 조상을 만드는 작업
- 구체화: 상속을 통해 클래스를 구현, 확장하는 작업
- 추상 메서드 대신 아무 내용도 없는 메서드로 만들어도 되는데 굳이 추상메서드로 선언하는 이유는 자손 클래스에서 **반드시 구현**하도록 가용하기 위해서다. 



### 7. 인터페이스(interface)

- 추상화 정도가 더 높은 추상클래스. 몸통을 갖춘 일반 메서드 또는 멤버변수를 가질 수 없다. **추상메서드**와 **상수**만 멤버로 가질 수 있다.
- class 대신 interface를 사용해 작성한다. 접근제어자로 public, default를 사용할 수 있다.
- 모든 멤버변수는 public static final 이어야 하며, 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 생략할 수 있다. 하지만 JDK 1.8부터 static 메서드와 디폴트 메서드 추가를 허용하도록 했다.
- 생략한 제어자는 컴파일 시에 컴파일러가 자동으로 추가해준다.
- 인터페이스는 인터페이스로부터만 상속받을 수 있고 **다중상속**이 가능하다. 하지만 실제로 다중 상속을 구현하는 경우는 거의 없다.
- 인터페이스를 구현하는 class는 extends대신 implements를 사용한다. 메서드 중 일부만 구현한다면 abstract를 붙여 추상 클래스로 선언해야 한다. 상속과 구현을 동시에 하는 것도 가능하다.

```java
class Fighter extends Unit implements Fightable {}
```

- 인터페이스 이름은 주로 able로 끝나는 것들이 많은데 어떤 기능을 하는데 필요한 메서드를 제공한다는 의미다. 필수 사항은 아니다.
- 오버라이딩 할 때는 조상 메서드보다 넓은 범위 접근 제어자를 지정해야 한다. 따라서 인터페이스 메서드는 public abstract가 붙어야 하므로 구현 클래스에서 메서드는 접근 제어자를 반드시 public으로 해야 한다.

- 앞서 배운 다형성에서 자손 클래스 인스턴스를 조상타입 참조변수로 참조하는 것이 가능하다고 배웠다. 인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있고 인터페이스 타입으로 형변환도 가능하다. 또 메서드 매개변수 타입으로 사용해 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 **매개변수로 제공**하게 만드는 것도 가능하다. 메서드 리턴타입으로 인터페이스 타입을 지정하면 해당 **인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미**한다.

- 인터페이스의 장점: 개발시간 단축(메서드 호출하는 쪽에서는 내용 관계없이 선언부면 알면 된다. 따라서 인터페이스 구현하는 클래스 작성하는 동안 기다리지 않고 개발이 가능하다.) / 표준화 가능 / 서로 관계없는 클래스들에게 관계를 맺어줌(상속관계, 조상 클래스가 같지도 않은 클래스들에게 하나의 인터페이스를 구현하도록해 관계를 맺어준다. => Marine, Tank, Dropshop등 공통점이 없는 유닛이 implements Repairable을 사용하고, repair 메서드의 매개변수로 Repairable r을 사용하는 등의 활용) / 독립적인 프로그래밍(클래스 선언과 구현을 분리해 실제 구현에 독립적인 프로그램 작성. 클래스 간의 관계를 간접적인 관계로 변경하면 한 클래스 변경이 다른 클래스에게 영향을 미치지 않는 독립적인 프로그래밍 가능)
- 데이터베이스 회사에서 관련 인터페이스를 구현한 클래스를 제공해 응용프로그램을 작성하는 쪽에서 인터페이스를 이용해 프로그램을 만들 수 있다. 
- 같은 클래스를 상속받는 네 개의 클래스가 있을 때 두 개의 클래스에만 메서드를 추가하고 싶다면 인터페이스를 이용하면 된다.
- 매개변수를 인터페이스로 제공받을 수 있지만 제3의 클래스를 통해 getInstance()라는 메서드로 제공받는다.나중에 다른 클래스의 인스턴스로 변경되어도 A클래스 변경없이 getInstance를 변경하면 된다.

```java
class A {
    void methodA() {
        I i = InstanceManager.getInstance();
        i.methodB();
    }
}

interface I  {
    public abstract void methodB();
}

class B implements I {
    public void methodB() {
        
    }
    
    public String toString() { return "class B"; }
}

class InstanceManager {
    public static I getInstance() {
        return new B();
    }
}
```

- 조상 클래스에 새로운 메서드를 추가하는 건 별 일이 아니지만 인터페이스에 추상 메서드를 추가하면 구현한 기존 모든 클래스에서 구현해야 하므로 큰 일이다. 따라서 디폴트 메서드를 만들게 됐다. 디폴트 메서드는 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다. 디폴트 메서드가 기존 메서드와 이름이 중복되어 충돌할 때 여러 인터페이스의 디폴트 메서드간 충돌이라면 인터페이스를 구현한 클래스에서 오버라이딩하고 디폴트 메서드와 조상 클래스 메서드의 충돌이라면 조상 클래스 메서드가 상속되고 디폴트 메서드는 무시된다.



### 8. 내부 클래스(inner class)

- 클래스 내부에 선언된 클래스. 서로 긴밀한 관계에 있다. 멤버들 간 서로 쉽게 접근할 수 있고 외부에는 불필요한 클래스를 감춰 코드의 복잡성을 줄인다.(캡슐화) / 바깥을 외부 클래스, 안을 내부 클래스라고 한다.
- 인스턴스 클래스: 멤버변수 선언위치에 선언, 인스턴스 멤버처럼 다루어짐. 외부 클래스 인스턴스 멤버들과 관련된 작업에 사용될 목적 / 외부 클래스 인스턴스를 먼저 생성해야만 생성할 수 있다.
- 스태틱 클래스: 멤버변수 선언위치에 선언, static 멤버처럼 다루어짐. static 멤버, 특히 static 메서드에 사용될 목적으로 선언 / 내부 클래스 중 스태틱 클래스만 static 멤버를 가질 수 있다.
- 지역 클래스: 메서드나 초기화 블럭 안에 선언. 선언 영역 내부에서만 사용
- 익명 클래스: 클래스 선언과 객체 생성 동시에 하는 이름없는 클래스(일회용)로 오직 하나의 객체만 생성할 수 있다. new 조상클래스의이름() {} 또는 new 구현인터페이스이름() {}를 사용해서 정의하기 때문에 클래스로 상속받으며 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현하거나 할 수 없다. 

```java
Object iv = new Object() { void method(){} };
```



- 내부 클래스와 외부 클래스에 선언된 변수 이름이 같을 때 변수 앞에 this 또는 외부클래스명.this를 붙여 서로 구별한다.



## Chapter 08 예외처리

### 1. 예외처리(exception handling)

- 컴파일 에러: 컴파일 시에 발생하는 에러. 컴파일러가 소스코드(*.java)에 대해 오타, 잘못된 구문, 자료형 체크 등 기본 검사 수행해서 오류 있는지 알려 준다. 에러가 없으면 클래스 파일(.class)이 생성되고 생성된 클래스 파일을 실행할 수 있게 되는 것이다.
- 런타임 에러: 실행 시에 발생하는 프로그램 오류.
  - 에러: 메모리부족, 스택오버플로우처럼 복구할 수 없는 심각한 오류
  - 예외: 발생해도 수습할 수 있는 오류. 적절한 코드를 미리 작성해 놓아 비정상적인 종료를 막을 수 있다. 예외 클래스의 최고 조상은 Exception클래스로 크게 Exception클래스와 그 자손들(RuntimeException과 자손들 제외), 그리고 RuntimeException클래스와 그 자손들로 나눌 수 있다.
    - RuntimeException클래스: 주로 프로그래머의 실수에 의해 발생되는 예외들. 예를 들면 배열 범위 벗어나거나 값이 null인 참조변수 멤버 호출, 형변환 잘못함, 정수를 0으로 나누려고 함 등.
    - 그 외 Exception클래스: 외부 영향으로 발생가능. 사용자들 동작에 의해서 발생. 존재하지 않는 파일 입력, 클래스 이름 틀림, 입력한 데이터 형식이 잘못됨.
- 논리적 에러: 실행은 되지만, 의도와 다르게 동작하는 것

- try-catch문: 예기치 못한 예외의 발생에 대비한 코드를 작성해 비정상 종료를 막고 정상적인 실행 상태를 유지한다. 처리되지 못한 예외는 JVM의 예외처리기가 받아서 원인을 화면에 출력한다.
  - if문과 달리 try나 catch블럭은 포함된 문장이 하나뿐이어도 괄호를 생략할 수 없다.
- catch블럭: 괄호()내에는 처리하고자 하는 예외와 같은 타입의 **참조변수 하나를 선언**해야 한다. 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다. 첫 번째 catch블럭부터 내려가면서 ()내에 선언된 참조변수의 종류와 생성된 예외 클래스의 인스턴스를 instanceof 연산자를 이용해 결과가 true인 블럭을 만들 때까지 계속된다. 또 모든 예외 클래스는 **Exception**클래스의 자손이므로 Exception 클래스 타입의 참조변수를 ()에 선언해두면 어떤 예외가 발생해도 처리 가능하다.
- 예외가 발생했을 때 생성되는 예외 인스턴스에는 정보가 담겨있고 이를 getMessage()나 printStackTree()를 통해 얻을 수 있다. catch 블럭의 ()에 선언된 참조변수를 통해 접근할 수 있다. 
  - printStackTree(): 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
  - getMessage(): 발생한 예외 클래스의 인스턴스에 저장된 메세지를 얻을 수 있다.
- 멀티 catch블럭: JDK 1.7부터 **|**를 사용해 하나의 catch블럭으로 합칠 수 있게 되었고 개수 제한은 없다. |는 논리 연산자가 아니라 기호이다. 만약 연결된 예외 클래스가 조상 자손 관계라면 컴파일 에러가 발생한다. 조상 클래스만 써주는 것과 똑같기 때문이다. 또 실제 어떤 예외가 발생했는지 알수 없어 e는 조상 예외 클래스의 멤버만 사용 가능하다. instanceof로 확인하고 형변환을 통해 개별적으로 처리할 수 있긴 하다. 

```java
try {
    ...
} catch (Exception A | Exception B e) {
    e.printStackTrace();
}
```

- 예외 발생시키기: 키워드 **throw**를 사용해 고의로 예외를 발생시킬 수 있다. 

  1. 먼저, 연산자 new를 이용해 발생하려는 예외 클래스의 객체를 만들고

  ```java
  // Exception 인스턴스 생성시, 생성자에 String을 넣어주면 인스턴스에 메시지로 저장되고 getMessage()를 이용해 얻을 수 있다.
  Exception e = new Exception("고의로 발생시켰음");
  ```

  2. 키워드 throw를 이용해 예외를 발생시킨다.

  ```java
  throw e;
  ```

- throw를 사용할 때 예외처리가 되어있지 않으면 컴파일할 때 에러가 발생한다. 하지만 RuntimeException을 throw하면 예외가 발생하지 않는다. 프로그래머에 의해 실수로 발생하는 것들이기 때문에 강제하지 않기 때문이다. 이처럼 예외처리를 확인하지 않는 클래스들은 unchecked예외, 확인하는 클래스들은 checked예외라고 한다.

- 메서드에 예외 선언하기: 메서드 선언부에 throws를 사용해 메서드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다. 여러 개도 가능하다. 최고조상인 Exception을 선언하면 모든 종류의 예외가 발생할 수 있다는 뜻이다. 선언부에 예외를 선언하면 사용하려는 사람이 선언부를 보고 이 메서드를 사용하기 위해선 어떤 예외들이 처리되어져야 하는지 쉽게 알 수 있다. 메서드에 예외를 선언할 때 반드시 처리해주어야 하는 예외들만 선언하기 때문에 일반적으로 **RuntimeException**클래스들은 적지 않는다. 

```java
void method() throws Exception1, Exception2, ... ExceptionN {
    
}
```

- 예외를 throws에 명시하는 것은 자신을 호출한 메서드에게 예외를 전달해 처리를 떠맡기는 것이다. 예외가 발생한 메서드 내에서 처리되면 호출한 메서드는 예외가 발생했다는 사실조차 모른다. 반면 호출한 메서드로 넘겨주면 호출한 라인에서 예외가 발생한 것으로 간주해 처리한다. 예외가 메서드 내에서 자체적으로 처리해도 되는 것은 메서드 내에서 try-catch문을 사용해 처리하고 메서드에 호출 시 넘겨받아야 할 값을 다시 받는 경우(자체 처리가 안되는 경우) 예를 메서드에 선언해 호출한 메서드에서 처리해야 한다.
- finally: try 블럭에서 return문이 실행되는 경우에도 finally 블럭의 문장들이 먼저 실행된 후 현재 실행 중인 메서드를 종료한다.
- 자동 자원 반환 - try - with - resources문: 입출력에 사용된 클래스 중 사용 후에 꼭 닫아 줘야 사용했던 자원이 반환되는 것들이 있다. finally에서 이를 처리했는데 close()도 예외를 발생시킬 수 있다. 따라서 finally에 try-catch를 추가하면 try와 finally의 try에서 모두 예외가 발생했을 때 try블럭의 예외가 무시된다.

```java
// 괄호 안에 객체를 생성하는 문장을 넣으면 close를 따로 호출하지 않아도 try를 벗어나는 순간 자동으로 close()가 호출된다. 그리고 catch 또는 finally가 수행된다. try 괄호 안에 변수를 선언하는 것도 가능하다.
try ( FileInputStream fis = new FileInputStream("score.dat"); DataInputStream dis = new DataInputStream(fis)) {
    
}
```

- 자동으로 close()가 호출될 수 있으려면 AutoCloseable이라는 인터페이스를 구현한 것이어야 한다. 여기서 close가 예외가 발생하면 일반 예외가 같은 형태로 출력된 후 close()의 예외는 억제된(suppressed)이라는 의미의 머리말과 함께 출력된다. 두 예외가 동시에 발생할 수 없어서이다. 억제된 예외의 정보는 실제 발생된 앞선 예외에 저장된다.
- 사용자정의 예외 만들기: Exception클래스나 RuntimeException클래스로부터 상속받아 만들지만 필요에 따라 알맞은 예외 클래스를 선택할 수 있다. 가능하면 기존 예외클래스를 활용하자. 기존엔 Exception을 주로 상속받아 checked예외로 작성하는 경우가 많았지만 요즘은 선택적으로 할 수 있도록 RuntimeException을 상속받아 작성하는 쪽으로 바뀌어가고 있다.
- 예외 되던지기(exception re-throwing): 예외가 여럿이면 몇 개는 try-catch문으로 메서드 내에서 자체적으로 처리하고 나머지는 선언부에 지정해 호출한 메서드에서 처리하도록 한다. 하지만 단 하나의 예외가 발생했을 때도 양 쪽에서 처리하도록 할 수 있다. 예외를 처리한 후 **인위적으로 다시 발생**시키는 방법이다. catch문에서 작업 후 throw문을 사용해 예외를 다시 발생시킨다. 주의할 점은 예외처리를 해 줌과 동시에 선언부에 발생할 예외를 throws에 지정해줘야 한다는 것이다. 
- 반환 값이 있는 return문의 경우 catch 블럭에도 return 문이 있어야 한다. 예외가 발생해도 값을 반환해야 하기 때문이다.  finally 블럭 내에도 return문을 사용할 수 있다. try나 catch return문 다음에 수행되어 최종적으로 finally 블럭 내의 return 값이 반환된다. 또는 예외 되던지기를 사용해 호출한 메서드로 예외를 전달하면 return이 없어도 된다.
- 연결된 예외(chained exception): 예외 a가 예외 b를 발생시켰다면 a를 b의 **원인 예외(cause exception)**라고 한다. install을 space와 memory의 조상으로 해서 catch 블럭을 작성하면 실제 발생한 예외가 어떤 것인지 알 수 없고 상속관계도 변경해야 한다. 따라서 예외가 원인 예외를 포함하게 하면 두 예외가 상속관계가 아니어도 상관없다. 또 다른 이유는 checked 예외를 unchecked 예외로 바꿀 수 있도록 하기 위해서다. throw new RuntimeException으로 예외를 감싸면 unchecked예외가 된다.

```java
try {
    startInstall();
    copyFiles();
} catch (SpaceException e) {
    InstallException ie = new InstallException("설치중 예외발생"); // 예외 생성
    ie.initCause(e); // 원인 예외를 SpaceException으로 지정
    throw ie;
}

// initCause는 Exception 클래스의 조상인 Throwable클래스에 정의되어 있어 모든 예외에서 사용 가능
// Throwable getCause() : 원인 예외를 반환
```



## Chapter 09 java.lang 패키지와 유용한 클래스

- java.lang 패키지: 자바 프로그래밍에 가장 기본이 되는 클래스(String, System등)가 포함되어 import문 없이도 사용 가능. 

- Object클래스의 메서드들

  - protected Object clone(): 객체 자신의 복사본 반환

    - clone()은 단순히 값을 복사하기 때문에 참조타입인 경우 완전한 복제가 이루어지지 않는다. 따라서 배열을 복제하면 복제 인스턴스도 같은 배열 주소를 가져 작업하면 원래 인스턴스에 영향을 미친다. 
    - clone메서드를 오버라이딩해서 새로운 배열을 생성하고 배열 내용을 복사하도록 해야 한다. 오버라이딩하며 protected 접근 제어자를 public으로 변경해야 상속관계가 없는 다른 클래스에서 clone을 호출할 수 있다.
    - clone()은 Cloneable을 구현하지 않은 클래스에서 호출되면 예외가 발생하는데 인스턴스 데이터를 보호하기 위해서다. 

    ```java
    class Point implements Cloneable {   // Cloneable 인터페이스 구현
        public object clone() {   // 접근제어자 public으로 변경
            Object obj = null;
            try {
                obj = super.clone();  // 조상 클래스 clone 호출. clone은 반드시 예외처리를 해줘야 함
            } catch(CloneNotSupportedException e) {}
            return obj;
        }
    }
    
    class CloneEx1 {
        public static void main (String[] args) {
            Point original = new Point(3, 5);
            Point copy = (Point)original.clone(); // return 타입이 Object라서 형변환
        }
    }
    ```

    - 공변 반환타입(covariant return type): 조상 메서드 반환타입을 자손 클래스 타입으로 변경 허용. 위에서처럼 형변환을 해줄 필요 없다. 
    - 일반적으로 배열 생성할 때 같은 길이 새로운 배열을 만든 후 System.arraycopy()를 이용해 내용을 복사한다.
    - 배열 뿐 아니라 java.util 패키지의 Vector, ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, Calendar, Date와 같은 클래스들이 이와 같은 방식으로 복제 가능하다. 
    - 기본배열은 clone으로 복제 가능하지만 객체 배열인 경우 완전한 복제가 되지 않는다. 이를 얕은 복사(shallow copy)라고 한다. 반면 원본이 참조하는 객체까지 복제하는 것을 깊은 복사(deep copy)라고 한다. 

  - equals(Object obj): 객체 자신과 obj가 같은 객체인지 알려줌

    - 두 객체 같고 다름을 참조변수의 값(주소값)으로 판단.
    - 주소값으로 비교하기 때문에 값이 같아도 false가 나올 수 있다.
    - value값을 비교하기 위해선 equals 메서드를 오버라이딩해 주소가 아닌 내용을 비교하도록 변경하면 된다.
    - String 클래스에서 이렇게 사용한다.(Date, File, wrapper-Integer, Double 에서도)

  - protected void finalize(): 객체가 소멸될 때 가비지 컬렉터에 의해 자동 호출. 수행되어야하는 코드가 있을 때 오버라이딩(거의 사용X)

  - getClass(): 객체 자신의 클래스 정보를 담은 Class 인스턴스 반환

    - 자신이 속한 클래스의 Class 객체를 반환한다. Class 객체는 이름이 Class인 클래스의 객체다. Class 객체는 클래스의 모든 정보를 담고 있으며 클래스 당 1개만 존재한다. 클래스 로더에 의해 메모리에 올라갈 때 자동으로 생성된다. 클래스 로더는 실행 시 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다. 기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고 있으면 참조 반환, 없으면 클래스 패스에 지정된 경로를 따라 클래스 파일을 찾는다. 못찾으면 ClassNotFoundException이 발생한다. 
    - Class 객체 얻는법: new Card().getClass()(생성된 객체로 부터 얻는 방법, 모든 정보를 얻을 수 있어 객체를 생성하고 메서드를 호출하는 동적인 코드 작성 가능), Card.class(리터럴로부터 얻는 방법), Class.forName("Card")(클래스 이름으로부터 얻는 방법, 특정 클래스 파일 예를 들어 데이터베이스 드라이버를 메모리에 올릴 때 주로 사용)

    ```java
    Card c = Card.class.newInstance(); // Class객체를 이용해 객체 생성, InstantiationException이 발생할 수 있어 예외처리 필요
    ```

    

  - hashCode(): 객체 자신의 해시코드 반환

    - 해싱 기법에 사용되는 해시함수 구현. 해싱은 데이터관리기법으로 다량의 데이터를 저장하고 검색하는 데 유용
    - 해시함수는 찾고자하는 값 입력하면 저장된 위치를 알려주는 해시코드 반환
    - 해시코드 메서드는 객체 주소값으로 해시코드를 만들어 반환하는데 32bit JVM에서는 결코 같은 해시코드를 가질 수 없었으나 64bit JVM에서는 중복가능성이 있다.
    - 앞서 값으로 객체의 같고 다름을 판단하는 경우라면 equals뿐 아니라 hashCode 메서드도 적절히 오버라이딩 해야한다. 같은 객체라면 해시코드도 같아야 한다.
    - String 클래스는 문자열 내용이 같으면 동일한 해시코드가 반환되도록 hashCode메서드가 오버라이딩 되어있다. 반면 System.identityHashCode(Object x)로 String 객체를 보면 원래 해시코드 메서드대로 객체 주소값으로 해시코드를 생성해 다른 해시코드 값을 반환한다.

  - toString(): 객체 자신의 정보를 문자열로 반환

    - 인스턴스에 대한 정보를 문자열로 제공한다. 오버라이딩 하지 않을 경우 클래스 이름 + @ + 16진수해시코드를 얻게 된다.
    - String이나 Date 클래스 같은 경우 문자열을 반환하도록, 날짜와 시간을 반환하도록 오버라이딩 되어있다. toString은 일반적으로 인스턴스나 클래스에 대한 정보 또는 인스턴스 변수들의 값을 문자열로 변환해 반환하도록 오버라이딩되는 것이 보통이다.
    - Object 클래스의 toString의 접근 제어자가 public이므로 오버라이딩 할 때도 같거나 넓은 범위에 속하는 public으로 오버라이딩 되어야 한다.

  - notify(): 객체 자신을 사용하려고 기다리는 쓰레드를 하나 깨움

  - notifyAll(): 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨움

  - wait(): 다른 쓰레드가 notify(), notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간 동안 기다리게 함



#### 1.2 String 클래스

- 기존 다른 언어는 문자열을 char의 배열로 다루었으나 자바에서는 클래스를 제공한다. String 클래스 역시 문자형 배열 참조변수 value를 인스턴스 변수로 정의해 매개변수로 입력받는 문자열이 이 인스턴스 변수에 저장되는 것이다. 
- String 클래스는 앞에 final이 붙어 있으므로 다른 클래스 조상이 될 수 없다. 
- 한 번 생성된 String 인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없다. +로 결합할 경우 인스턴스 내의 문자열이 바뀌는 것이 아니라 새로운 String인스턴스가 생기는 것이다. 따라서 매 연산시마다 인스턴스가 새로 생성되므로 메모리공간을 차지해 가능한 한 결합횟수를 줄이는 게 좋다. 
  - 따라서 문자열 결합, 추출 등을 많이 사용할 경우 **StringBuffer 클래스**를 이용하는 것이 좋다. StringBuffer 인스턴스에 저장된 문자열은 변경이 가능하다.
- 문자열 비교: 문자열을 만들 때 리터럴을 지정하는 방법과 String클래스의 생성자를 사용해 만드는 방법이 있다. 생성자를 이용한 경우 new에 의해 메모리 할당이 이루어지고 항상 새로운 String 인스턴스가 생긴다. 하지만 문자열 리터럴은 이미 존재하는 것을 재사용한다. 따라서 equals로 비교했을 경우 값을 비교하기 때문에 두 경우 모두 true를 얻지만 인스턴스 주소를 ==로 비교했을 경우 후자는 false를 갖는다.
- 문자열 리터럴: 자바 소스파일의 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 같은 내용 문자열 리터럴은 한 인스턴스를 공유하기 때문에 한번만 저장된다. 클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때 리터럴 목록의 리터럴들이 JVM내의 **상수 저장소**에 저장된다.
- 빈 문자열: 길이가 0인 배열은 모든 타입에서 가능하다. 길이가 0인 char형 배열을 내부적으로 가지고 있는 문자열이 빈 문자열이다. (char c = ""; 는 불가능. 반드시 하나를 지정해야 함)
  - 변수 선언 시 보통 기본값으로 초기화하지만 String은 참조형의 기본인 null보다는 빈 문자열, char형은 공백으로 초기화 하는 것이 보통이다.
- String 클래스의 메서드
  - int compareTo(String str): 사전순서로 비교해 같으면 0, 이전이면 음수, 이후면 양수
  - String concat(String str): 문자열을 뒷에 덧붙인다.
  - boolean contains(charSequence s): s가 포함되었는지 검사
  - boolean endsWith(String suffix), startsWith(String prefix): suffix로 끝나는지 검사, prefix로 시작하는지 검사
  - boolean equalsIgnoreCase(String str): 대소문자 구분없이 비교
  - int indexOf(int ch **or** String str): 문자나 문자열이 문자열에 존재하는지 확인해 위치 반환. 없으면 -1
  - int indexOf(int ch, int pos): ch가 존재하는지 pos부터 확인해서 알려줌
  - char charAt(int index): 지정위치의 문자 알려줌
  - String intern(): 문자열을 **상수풀**에 등록한다. 같은 내용이 있으면 그 문자열 주소값 반환
  - int lastIndexOf(int ch **or** String str): 문자나 문자열을 오른쪽 끝에서부터 찾아서 위치 반환
  - String replace(char old, char nw): (문자)old를 nw로 바꿔서 반환
  - String replace(charSequence old, CharSequence nw): (문자열)old를 nw로 모두 바꾼 문자열 반환
  - String replaceAll(Strign regex, String replacement): 지정된 문자열 regex과 일치하는 것을 새로운 문자열 replacement로 모두 변경 (정규표현식 사용가능)
  - Strign replaceFirst(String regex, String replacement): 문자열 중에서 지정된 문자열(regex)과 일치하는 것 중 첫번째만 새로운 문자로 변경 (정규표현식 사용가능)
  - String[] split(String regex, int limit): 문자열을 지정된 분리자로 나누어 문자열배열에 담아 반환. 단, 문자열 전체를 지정된 수로 자른다.
  - String substring(int begin, int end): begin부터 end까지 범위의 문자열 얻는다. 시작위치는 문자 범위에 포함되고 끝 위치는 포함되지 않으며 끝 위치는 지정하지 않아도 된다.
  - String toString(): 인스턴스에 저장된 문자열 반환
  - String trim(): 양 끝 공백 없앤 결과 반환. 중간은 x
  - static String valueOf(): boolean, char, int, long, float, double, Object가 들어갈 수 있으며 지정된 값을 문자열로 변환해 반환한다. 참조변수는 toString() 호출 결과 반환. 빈 문자열을 더해서 숫자에서 문자열로 변경하기 쉽지만 성능면에서는 valueOf를 사용하는 것이 좋다.
  - join: 구분자를 넣어서 결합
  - java.util.StringJoiner 클래스: (구분자, 맨 앞에 올 글자, 맨 뒤에 올 글자)를 사용해 결합
- 유니코드는 2 byte, 16비트 문자체계인데 모자라 20비트로 확장. 그래서 하나의 문자를 char로 다루지 못하고 int로 다룰 수밖에 없다. 새로 추가된 문자들을 보충 문자라고 한다. 위의 메서드 중 매개변수가 int ch인 것은 보충문자를 지원하고 char ch는 지원하지 않는 것이다.
- 문자 인코딩 변환: getBytes(String charestName)을 사용하면 문자열 문자 인코딩을 다른 인코딩으로 변경할 수 있다. 자바는 UTF-16을 사용하지만 문자열 리터럴에 포함되는 문자들은 OS의 인코딩을 사용한다. 한글 윈도우즈는 CP949를 사용한다. 변경하려면

```java
byte[] uft8_str = "가".getBytes("UTF-8");
String str = new String(utf8_str, "UTF-8");   // byte 배열을 문자열로 변환
```

- String.format(): 형식화된 문자열 만들어내기. printf와 사용법이 같다. 
- String을 기본형 값으로 변환: valueOf()를 쓰거나 parseInt()를 사용한다. valueOf 반환타입은 int가 아닌 Integer인데 오토 박싱에 의해 int로 자동 변환된다. 예전에는 parseInt를 많이 사용했으나 메서드 이름을 통일하기 위해 valueOf가 추가되었다. 메서드 내부에서는 parseInt를 호출하므로 사실 같은 메서드다. 그 외 Boolean.parseBoolean, Dobule.parseShort, parseDouble등이 있다. 기본형 타입 이름 첫 글자가 대문자인 것은 래퍼 클래스(wrapper class)다. 기본형 값을 감싼 클래스라는 뜻에서 붙여진 이름으로 기본형을 클래스로 표현한 것이다.
  - parseInt()나 parseFloa()등은 문자열에 공백, 문자가 포함되어있으면 NumberFormat Exception이 발생할 수 있으므로 trim()을 습관적으로 사용해야한다. 하지만 +(parseInt로 가능. JDK1.7부터), 소수점, f등은 자료형에 알맞은 변환을 하는 경우에 허용 가능하다. 1.0f는 parseInt에서는 예외가 발생하지만 parseFloat은 가능하다. 하지만 integer.parseInt("a", 16)은 16진수에서 a의 값인 10이다.

```java
int i = Integer.parseInt("100");
int i2 = Integer.valueOf("100");
```



#### 1.3 StringBuffer클래스와 StringBuilder클래스

- String 인스턴스는 지정된 문자열 변경 불가능하지만 StringBuffer는 가능하다. 내부적으로 문자열 편집을 위한 버퍼를 가지고 있고 인스턴스 생성할 때 그 크기를 지정할 수 있다.(지정하지 않으면 버퍼 크기는 16) 따라서 편집할 문자열 길이를 고려해 버퍼 길이를 충분히 잡아준다. 버퍼 길이를 넘어서면 새로운 길이 배열을 생성후 이전 배열 값을 복사하기 때문에 효율이 떨어진다.
- String과 마찬가지로 char형 배열의 참조변수를 인스턴스 변수로 선언해 놓고 있다.
- StringBuffer의 메서드 append는 반환타입이 StringBuffer로 문자열을 추가하고 자신의 주소를 반환한다. 자신을 반환하기 때문에 연속적으로 append를 호출할 수 있다. void라면 불가능했을 것이다.
- String은 equals를 오버라이딩 해서 값을 비교하지만 StringBuffer는 오버라이딩하지 않아 등가비교연산자로 비교한 것과 같은 결과를 얻는다.
- toString()은 오버라이딩 되어있어 호출하면 담은 문자열을 String으로 반환한다.
- 메서드: String과 유사한 메서드가 많으며 추가, 변경, 삭제와 관련된 메서드 추가 제공
  - StringBuffer(int length): StringBuffer 인스턴스 생성. length 미입력시 16문자 담을 수 있는 버퍼
  - StringBuffer(String str): 문자열 값 갖는 인스턴스 생성
  - StringBuffer append(): boolean, char, char[], couble, float, int, long, Object, String으로 입력된 값을 문자열로 변환해 뒤에 덧붙인다.
  - int capacity(): 버퍼 크기를 알려준다. length()는 버퍼에 담긴 문자열 길이를 알려준다.
  - char charAt(int index): 지정된 위치에 있는 문자 반환
  - StringBuffer delete(int start, int end): 시작부터 끝 사이의 문자 제거(끝 위치 문자 제외)
  - StringBuffer deleteCharAt(int index): 지정된 위치 문자 제거
  - StringBuffer insert(int pos, ): boolean, char, char[], couble, float, int, long, Object, String을 두 번째 매개변수로 받아 문자열로 변환후 지정 위치에 추가
  - StringBuffer replace(int start, int end, String str): 지정 범위 문자를 주어진 문자열로 변경(end의 문자 포함x)
  - StringBuffer reverse(): 순서 거꾸로 나열
  - void setCharAt(int index, char ch): 지정 위치 문자를 주어진 문자로 변경
  - void setLength(int newLength): 지정된 길이로 문자열 길이 변경. 늘리면 빈공간을 널문자로 채움
  - String substring(int start, int end): 지정 범위 문자열 String으로 반환(end 지정하지 않으면 끝까지)
- StringBuilder: 멀티쓰레드에 안전하도록 동기화 되어있다. 동기화가 StringBuffer 성능을 떨어뜨려 멀티쓰레드로 작성된 프로그램이 아니면 StringBuffer동기화가 성능을 떨어뜨린다. 따라서 StringBuffer에서 쓰레드의 동기화만 뺀 StringBuilder가 새로 추가되었다. 완전히 똑같은 기능으로 StringBuffer만 StringBuilder로 바꾸면 된다. StringBuffer도 성능이 좋아 꼭 향상이 필요한 경우만 바꾼다.



#### 1.4 Math클래스

- 생성자의 접근 제어자가 private으로 다른 클래스에서 인스턴스를 생성할 수 없다. 클래스 내에 인스턴스 변수가 없어 생성할 필요가 없고 메서드는 모두 static이며 자연로그의 밑과 원주율만 상수로 지정해두었다.
- 올림, 버림, 반올림
  - round(): 소수점 첫째자리에서 반올림 해서 정수값(long)반환
  - 소수점 n번째 자리에서 반올림한 값 얻기: 10의 n제곱으로 곱하기(소수 둘째자리까지 얻고 싶다면 100, 셋째자리면 1000 이런 식으로) -> Math.round()사용 -> 10의 n제곱.0으로 나누기(.0안붙이면 정수결과)
  - celi(): 올림
  - floor(): 버림
  - rint(): round()처럼 소수점 첫 째자리에서 반올림하는데 반환값은 dobule, 두 정수 정가운데 있는 값은 가장 가까운 짝수를 반환한다.(-1.5인경우 -2반환)
- 예외를 발생시키는 메서드: 이름에 Exact가 포함되어있는 메서드가 JDK1.8부터 추가됨. 정수형 연산에서 발생가능한 오버플로우 감지
  - addExact, stbtractExact, multiplyExact, incrementExact(int a) -> a++, decrementExact, negateExact(int a)->-a, toIntExact(long value)-> int로 형변환
  - 오버플로우가 발생하면 ArithmeticException을 발생시킨다.
  - negateExact(int a): 부호를 반대로 바꾸는 식은 ~a+1로 ~a의 결과가 int의 최대값이면 오버플로우가 발생할 수 있다. 오버플로우가 발생했는데 형변환을 하지 않았다면 오버플로우로 인해 다시 원래 값으로 되어버린다.
- pow(int a, int b): a의 b제곱 구하기
- sqrt(int a): a의 제곱근 구하기
- StrictMath클래스: Math클래스는 최대한의 성능을 얻기 위해 JVM이 설치된 OS의 메서드를 호출해 사용한다. 따라서 이런 차이를 없애기 위해 성능을 약간 포기하고 어디서 실행되어도 같은 결과를 얻는 StrictMath클래스가 새로 작성되었다.
- 메서드
  - abs(): double, float, int, long의 절대값 반환
  - max(a, b): double, float, int, long의 두 값을 비교해 큰 쪽 반환 / min
  - static double random(): 0.0 ~ 1.0범위의 임의의 dobule 반환(1.0은 포함x)



#### 1.5 래퍼(wrapper) 클래스

- 객체지향 개념에서는 모든 것을 객체로 다루어야 하는데 자바는 8개의 기본형을 객체로 다루지 않는다. 그래서 완전한 객체지향 언어가 아니라는 이야기를 듣지만 보다 높은 성능을 얻을 수 있다.
- 하지만 기본형을 어쩔 수 없이 객체로 다뤄야할 때가 있다. **매개변수로 객체 요구, 객체로 저장해야할 때, 객체간 비교 필요할 때** 등이다. 이 때 기본형 값을 객체로 변환하기 위해 사용되는 것이 래퍼 클래스다. 기본형이 8개이므로 래퍼클래스도 8개가 있다.
- char는 Character, int는 Integer이고 나머지는 앞글자만 대문자로 바꾸면 된다.
- 래퍼 클래스 생성자는 매개변수로 각 자료형 값을 인자로 받는다.
- 래퍼 클래스들은 모두 equals()가 오버라이딩 되어있어 값으로 비교할 수 있다. 또 compareTo()를 제공한다.
- toString()이 오버라이딩 되어있고 MAX_VALUE, MIN_VALUE, SIZE, BYTES, TYPE등의 static상수를 공통적으로 가지고 있다.
- Number클래스: 추상클래스. 숫자를 멤버변수로 가지는 래퍼클래스들의 조상. 그 외에 자손으로 BigInteger, BigDecimal도 가진다. 첫번째는 long으로도 다룰 수 없는 큰 범위 정수, 두번째는 dobule로도 다룰 수 없는 큰 부동 소수점수를 처리하기 위한 것으로 다양한 메서드를 제공한다.
- 문자열 숫자 변환: 원래 두번째는 기본형 반환, 세번째는 래퍼 클래스 반환이었으나 JDK 1.5부터 오토박싱 기능으로 차이가 없어졌다. 또한 다른 진법일 경우 뒤에 써주면 변환 가능하다.

```java
int i = new Integer("100").intValue();
int i2 = Integer.parseInt("100");
int i3 = Integer.valueOf("100");
```

- 오토박싱 & 언박싱: JDK1.5 이전에는 기본형과 참조형 연산이 불가능했으나 이제 컴파일러가 자동으로 intValue()를 추가해 변환하는 코드를 넣어줘 가능해졌다. 또한 내부적으로 객체 배열을 가지는 Vector클래스나 ArrayList클래스에 기본형을 저장할 때도 컴파일러가 자동으로 변환해준다.
  - 오토 박싱: 기본형을 래퍼 클래스 객체로 자동 변환
  - 오토 언박싱: 래퍼클래스에서 기본형으로 자동 변환

