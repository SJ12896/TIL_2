## Java의 정석

### Chapter01 자바를 시작하기 전에

#### 1.1 자바란?

- 썬 마이크로시스템즈에서 개발한 객체지향 프로그래밍 언어
- 운영체제에 독립적이어서 종류에 관계없이 실행가능해 프로그램을 전혀 변경하지 않고도 실행이 가능
- 풍부한 클래스 라이브러리(Java API)를 통해 프로그래밍에 필요한 요소들을 기본적으로 제공



#### 1.3 자바언어의 특징

1. 운영체제에 독립적: 자바 프로그램이 운영체제, 하드웨어가 아닌 에뮬레이터 `자바가상머신(JVM)`하고만 통신해 JVM이 받은 명령을 해당 운영체제가 이해할 수 있도록 변환해 전달한다. JAVA로 작성한 프로그램과 달리 JVM은 운영체제에 종속적이어서 서로 다른 버전의 JVM이 제공되고 있다. Write once, Run anywhere
2. 객체지향언어: 상속, 캡슐화, 다형성이 잘 적용되었다. 재사용성 & 유지보수의 용이성
3. 비교적 배우기 쉬움: C++과 스몰톡의 장점을 취하고 복잡한 부분은 제거. 많은 장점에도 불구하고 배우기 어려웠던 객체지향 프로그래밍의 저변 확대에 큰 기여를 했다.
4. 자동 메모리 관리(Garbage Collection): 자바 프로그램이 실행되면 가비지 컬렉터가 자동적으로 메모리를 관리해줘 프로그래머가 수동적으로 사용하지 않는 메모리를 체크하고 반환하는 관리가 필요 없다.
5. 네트워크와 분산처리 지원: 라이브러리를 통해 비교적 짧은 시간에 네트워크 관련 프로그램 쉽게 개발
6. 멀티쓰레드 지원: 일반적으로 운영체제에 따라 구현방법과 처리방식이 다르지만 자바에서 개발되는 멀티쓰레드 프로그램은 시스템과 관계없이 구현 가능하며 라이브러리가 제공되어 쉽다. 여러 쓰레드에 대한 스케줄링을 자바 인터프리터가 담당한다.
7. 동적 로딩 지원(Dynamic Loading): 보통 자바 애플리케이션은 여러 클래스로 구성되는데 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 로딩할 수 있다. 또 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 되고 비교적 적은 작업으로 변경사항을 처리할 수 있다.



#### 1.4 JVM(Java Virtual Machine)

- 자바를 실행하기 위한 가상 컴퓨터(소프트웨어로 구현된 컴퓨터)
- 가상 기계: 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어
- 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되는데 자바 애플리케이션은 JVM을 거쳐야하고 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시 해석되기 때문에 속도가 느리다는 단점이 있었다.  그러나 바이트코드(컴파일된 자바코드)를 하드웨어 기계어로 바로 변환하는 JIT 컴파일러와 Hotspot같은 신기술 도입으로 JVM 기능이 향상되어 속도문제가 개선되었다.



#### 2. 자바개발환경 구축하기

#### 2.1 자바 개발도구(JDK) 설치하기

- 자바 프로그래밍을 위해서 먼저 JDK(Java Development Kit)를 설치해야 한다. JDK를 설치하면 JVM, 자바클래스 라이브러리와 개발에 필요한 프로그램들이 설치된다. 
- JDK설치 후 설치 디렉토리 bin을 path에 추가해야한다. 이 디렉토리에 자바로 프로그램을 개발하는데 필요한 실행파일들이 있다. path는 OS가 파일 위치를 파악하는데 사용하는 경로로 path에 디렉토리를 등록하면 해당 디렉토리에 포함된 파일을 경로없이 이름만으로 사용할 수 있게 된다. 
- JDK bin 디렉토리의 주요 실행파일들: javac.exe(자바 컴파일러. 소스코드를 바이트코드로 컴파일) / java.exe(자바 인터프리터. 컴파일러가 생성한 바이트코드 해석하고 실행) / javap.exe(역어셈블러. 컴파일된 클래스파일을 원래 소스로 변환) / javadoc.exe(자동문서생성기. 소스파일의 주석을 이용해 API문서같은 형식 문서를 자동 생성) / jar.exe(압축프로그램. 클래스파일과 프로그램 실행 관련 파일을 하나의 jar파일로 압축하거나 압축해제한다.)
- JRE: 자바실행환경(Java Runtime Enviornment). 자바로 작성된 응용프로그램이 실행되기 위한 최소환경
- JDK = JRE + 개발에 필요한 실행파일
- JRE = JVM + 클래스 라이브러리(Java API)



#### 2.2 Java API문서 설치하기



### 3. 자바로 프로그램작성하기

#### 3.1 Hello.java

- 자바에서 모든 코드는 반드시 클래스 안에 존재해야 하고 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스를 구성하게 된다. 
- 소스파일의 이름은 public class의 이름과 일치해야 한다. 소스파일 내에 public class가 없다면 소스파일 이름은 소스파일 내의 어떤 클래스 이름으로 해도 상관없다. 
- 소스파일(.java)과 달리 클래스파일(.class)은 클래스마다 하나씩 만들어진다.



#### 3.2 자주 발생하는 에러와 해결방법

#### 3.3 자바 프로그램 실행과정

1. 프로그램 실행에 필요한 클래스를 로드한다.
2. 클래스 파일을 검사한다.
3. 지정된 클래스에서 main메서드를 호출한다.



### Chapter02 변수

### 1. 변수(variable)

- 단 하나의 값을 저장할 수 있는 메모리상의 공간
- 메모리는 여러 프로그램이 공유하는 자원으로 다른 프로그램에 의해 저장된 알 수 없는 값이 남아있을 수 있어 사용 전 **초기화**(사용하기 전 처음으로 값 저장) 해야한다.
- 변수 사용가능 특수문자: _ $
- 필수는 아니지만 권장하는 규칙: 클래스 이름 첫 글자는 항상 대문자 / 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 / 상수 이름은 모두 대문자며 여러 단어인 경우 _로 구분



### 2. 변수의 타입

- 자료형은 크게 기본형 / 참조형으로 나뉜다.
  - 기본형: 실제 값 저장 / C언어와 달리 참조형 변수간 연산 불가능, 실제 연산에 사용되는건 boolean을 제외한 기본형이므로 서로 변환 가능 / 논리형(boolean), 문자형(char), 정수형(byte, short, **int**, long), 실수형(float, **double**)
  - 참조형: 어떤 값이 저장된 주소 / 기본형 제외한 나머지 / JVM이 32 bit면 4 byte, 64 bit면 8 byte
- 참조형 변수를 선언할 때 변수 타입으로 클래스 이름을 사용한다. 클래스 이름은 참조변수 타입이 되므로 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.
- int는 대략 10자리수(약 20억)의 값을 저장할 수 있다.
- 실수형은 큰 값을 저장할 수 있지만 오차가 발생할 수 있다. float은 정밀도가 7자리로 10진수 7자리의 수를 오차없이 저장, dobule은 15자리

#### 2.2 상수와 리터럴

- JDK 1.6부터 상수를 선언과 동시에 초기화 하지 않아도 된다. 하지만 선언과 동시에 초기화하는 편이 좋다. 상수를 사용하면 다른 값을 계산할 때 여러 곳 수정할 필요 없고 이해와 수정을 돕는다.
- 리터럴: 그 자체로 값을 의미하는 것

- 접미사: L(정수 long 타입일 경우) / f, d(double이 기본이라 생략 가능) / 대소문자 상관X
- 접두사:  0을 붙이면 8진수, 0x는 16진수, 0b는 2진수로 저장 / 대소문자 상관X
- JDK 1.7부터 정수형 리터럴 중간에 구분자_를 넣어 큰 숫자를 편하게 읽을 수 있게 했다.
- 리터럴에 소수점이나 십의 제곱을 나타내는 e 또는 접미사 f, d등이 있으면 실수형으로 간주, 드물지만 p도(2의 제곱 의미하며 16진 지수형태 표현)
- 타입의 불일치: 저장범위가 넓은 타입에 좁은 값 저장은 허용
- 문자 리터럴: 작은 따옴표로 문자 하나 감싼 것으로 반드시 ''안에 하나의 문자 필요



#### 2.3 형식화된 출력 - printf()

- 지시자를 이용해 변수 값을 여러 형식으로 변환해 출력한다. 지시자 개수 제한은 없으며 줄바꿈을 하려면 %n을 넣어준다.(\n도 가능하지만 OS마다 다를 수 있어 %n 권장)
- %b: boolean / %d: 10진(decimal) / %o: 8진(octal) / %x: 16진(hexa) / %f: 부동소수점(floating-point) / %e: 지수(exponent) / %c: 문자(character) / %s: 문자열(string)
- 출력될 값이 차지할 공간을 숫자로 지정 가능
  - %와 지시자 사이에 숫자가 공간 크기
  - 크기 앞에 -를 붙이면 오른쪽부터 공간 차지
  - 숫자나 문자를 써넣으면 해당 글자가 남는 공간을 차지
  - .숫자를 써넣으면 왼쪽에서부터 숫자만큼만 출력
  - %f는 기본적으로 6자리만 출력하므로 7번째에서 반올림된다. 따라서 숫자.숫자를 사용해 소수 자리수를 지정가능한다. 모자르면 0으로 채워진다.
- %x(%X), %o에 #을 사용하면 0x, 0이 붙는다.
- 10진수 -> 2진수로 출력하는 지시자는 없기 때문에 문자열 지시자를 사용후 Integer.toBinaryString(binNum)을 이용한다.
- char타입을 %d로 출력할 수 없다. 형변환 필요



#### 2.4 화면에서 입력받기

- 연속적으로 값을 입력받을 때 nextLine()으로 입력받은 후 변환하는 것을 추천한다.



### 3. 진법

#### 3.2 비트와 바이트

- 비트: 한 자리의 2진수 / 1비트는 컴퓨터가 값을 저장할 수 있는 최소단위
- 바이트: 1 비트는 너무 작아 1 비트를 8개 묶어 바이트로 정의하고 데이터 기본 단위로 사용
- 워드: CPU가 한 번에 처리할 수 있는 데이터의 크기. CPU 성능에 따라 달라져 32비트에선 32비트고 64비트에선 64비트가 된다.

#### 3.3 진법변환

- 2진수 -> 8진수: 2진수를 뒤에서부터 3자리씩 끊어 해당하는 8진수로 바꾼다. 
- 10진 소수점수 -> 2진 소수점수: 10진 소수점수에 2를 곱해서 나온 결과에서 소수부만 가져다 계속 2를 곱한다. 소수부가 0이 될때까지 반복한다. 그리고 곱한 결과 값에서 정수부만을 위에서 아래대로 적고 0.을 붙이면 된다.



#### 3.6 음수의 2진 표현 - 2의 보수법

- n비트의 2진수로 표현할 수 있는 값의 개수는 2ⁿ개로 모두 부호없는 정수다. 
- 음수를 표현하는 법1: 1로 시작하는 2진수를 음수표현에 사용하고 순차적으로 -0부터 시작한다. 하지만 두 수를 더했을 때 2진수로 0이 되지않고 2개의 0이 존재하는 단점이 있다. 또 2진수가 증가할 때 10진 음수는 감소한다.
- 2의 보수법
  - 절대값이 같은 양수 음수를 더했을 때 2진수로도 0의 결과를 얻게되고 2진수가 증가할 때 10진 음수도 증가한다. 
  - n의 보수: 더했을 때 n이 되는 수
  - 2진수로 10은 **자리올림이 발생하고 0이 되는 수를 뜻한다.** (이 부분 약간 애매. 더 찾아볼 것)
  - 음수를 2진수로 표현하기 위해서는 절대값의 2진수를 구한 후 2의 보수를 구하면 된다.
  - 2의 보수 = 1의 보수 + 1 / 2진수에서 1의 보수를 더하면 모든 자리가 1이 된다. 여기서 양변에 1을 더하면 우변은 0이 되는데 올림이 발생하지만 4비트를 넘어 저장할 공간이 없어 버려진다. 



### 4. 기본형(primitive type)

#### 4.2 문자형 - char

- char에는 문자가 아닌 문자의 유니코드가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장한다. 그래서 문자의 유니코드를 직접 저장해도 동일한 결과를 가진다.
- tab은 \t, backspace는 \b 등 특수문자를 저장할 수 있다.
- char는 2byte(=16bit)로 모두 2¹⁶개의 값을 표현할 수 있고 0포함 모든 양수여야 한다. 반면 short는 같은 크기지만 절반을 음수 표현에 사용한다. char에 A, short에 65를 저장하면 둘 다 2진수로 같은 값이 저장되지만 println()으로 출력할 때 변수 타입이 정수형이면 변수에 저장된 값을 10진수로 해석해 출력하고 문자형이면 저장된 숫자에 해당하는 유니코드 문자를 출력한다.
- 문자 -> 코드: 인코딩, A -> 65
- 코드 -> 문자: 디코딩, 65 -> A
- 유니코드: 전 세계 모든 문자를 하나의 통일된 문자집합으로 표현하고자 노력한 결과. 유니코드에 포함시키고자 하는 문자들의 집합을 정의한 것을 유니코드 문자 셋이라고 한다. 그리고 이 문자셋에 번호를 붙인 것이 유니코드 인코딩이다. UTF-16은 자바에서 사용하며 모든 문자를 2byte 고정 크기로 표현한다. UTF-8은 1~4 byte 가변크기로 표현한다. UTF-16은 1byte로 표현가능한 영어와 숫자도 2byte로 표현되어 문서의 크기가 커지는 단점이 있다. 인터넷에서 문서 크기가 작을수록 전송속도에 좋기 때문에 UTF-8로 작성된 웹문서가 빠르게 늘고 있다.

#### 4.3 정수형 -byte, short, int, long

- 어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다. 
  - 정수형의 저장: 부호비트 + (n-1)bit 
  - n비트로 표현할 수 있는 정수의 개수: 2ⁿ개(최대값은 절반에서 1을 빼야한다. 0도 포함되기 때문)
- 오버플로우: 연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것. 부호없는 정수는 2진수로 0000이 될 때 오버플로우가 발생하고 부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생.
  - 최소값에서 1을 빼면 최대값이 되고 최대값에서 1을 더하면 최소값이 된다.

#### 4.4 실수형 - float, double

- 실수형은 얼마나 큰 값은 표현할 수 있는가 뿐만 아니라 얼마나 0에 가깝게 표현할 수 있는가도 중요하다.
- 실수형에서 오버플로우가 발생하면 변수 값은 무한대가 된다. 그리고 정수형에 없는 언더플로우가 있는데 실수형으로 표현할 수 없는 아주 작은 값, 양의 최소값보다 작은 값이 되는 경우를 말한다.
- 정수형은 부호와 값으로 이루어져있지만 실수형은 부호(S), 지수(E), 가수(M) 세부분으로 이루어져있다. 2의 제곱을 곱한 형태로 저장(+-M * 2의 E승)하기 때문에 큰 범위를 저장하는 게 가능하다. 
- 그러나 정수형과 달리 오차가 발생할 수 있다는 단점이 있다. 실수형은 표현할 수 있는 값의 범위 뿐 아니라 정밀도가 중요한 요소다. 
- 부호: 0이면 양수, 1이면 음수. 정수형과 달리 2의 보수법을 사용하지 않아 양의 실수 -> 음의 실수 하려면 부호비트만 0에서 1로 변경 / 1
- 지수: 부호있는 정수. / float은 8, double은 11
- 가수: 실제값을 저장하는 부분. / float은 23, double은 52 / float 2진수 23자리로 7자리 10진수를 저장할 수 있는데 이게 바로 float의 정밀도가 된다. 



### 5. 형변환

- float을 int로 변환할 때 소수점 이하의 값은 반올림이 아닌 버림 처리된다.
- 실수형간의 형변환
  - float -> double: 지수는 float의 기저인 127을 빼고 double의 기저인 1023을 더해서 변환
  - double -> float: 지수는 double의 기저인 1023을 빼고 float의 기저인 127을 더함. 가수는 double의 가수 52자리 중 23자리만 저장되고 나머지 버림. 그런데 가수 24번째 자리에서 반올림 발생할 수 있다. 24자리가 1이면 23번째 자리가 1이 증가한다. / 또한 float의 범위를 넘는 값을 float으로 형변환하면 플러스마이너스 무한대 또는 플러스마이너스 0을 얻게된다.
- 정수형 -> 실수형: 2진수로 변환 후 정규화를 거쳐 실수 저장형식으로 저장된다. 다만 int는 최대 10자리의 정밀도를 요구하는데 float은 7자리만을 제공하므로 정밀도 차이에 의한 오차가 발생할 수 있다. 
- 실수형 -> 정수형: 소수점 이하 값은 버려진다. 형변환 시 반올림이 발생하지 않는다.
- 자동 형변환: 변수가 저장가능한 값 범위보다 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생하지만 명시해줬을 경우 의도적인 것으로 간주하고 에러를 발생시키지 않는다. 서로 다른 두 타입의 덧셈에서는 표현범위가 더 넓은 타입으로 형변환해 일치시킨 다음 연산을 수행한다. 



## Chapter 03 연산자

- 쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다.
- 비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮다. ex) data & 0xFF == 0 에서 ==먼저 실행
- 보통 왼쪽에서 오른쪽 순서로 연산을 수행하지만 단항 연산자와 대입 연산자만 오른쪽에서 왼쪽 순서로 수행한다. 
- 우선순위: 산술 > 비교 > 논리 > 대입 / 단항 > 이항 > 삼항
- 산술 변환: 피연산자의 타입 일치를 위해 자동으로 형변환되는 것. 보통 둘 중 큰 타입으로 맞춰지지만 피연산자의 타입이 int보다 작다면 int로 변환된다.(byte + short같은 경우) 따라서 byte + byte 결과를 byte 타입의 변수에 저장하려면 형변환이 필요하다.
- 연산결과의 타입은 피연산자의 타입과 일치한다. int와 int를 나눈 결과는 int다. 
- int a, b가 있을 때 long c = a * b이고 결과 값이 int의 범위를 넘어서는 값이라면 결과 변수가 long이라 제대로 계산된 값이 나올 것 같지만 a * b의 값이 이미 int의 값이므로 잘못된 값이 나온다. 따라서 a 또는 b를 long으로 형변환해 계산해야 한다. 
- char c2 = 'a'; c2 = c2 + 1;이란 코드를 작성하면 c2가 계산과정에서 자동으로 int로 형변환되었고 그 결과를 char에 담으려 해서 오류가 발생한다. 하지만 char c2 = 'a' + 1;은 오류가 발생하지 않는데 리터럴 간의 연산이기 때문이다. **상수 또는 리터럴 간의 실행과정동안 변하는 값이 아니기 때문에 컴파일 시 컴파일러가 계산해서 그 결과로 대체**한다. 컴파일러가 미리 덧셈연산을 수행하므로 실행 시에는 연산이 수행되지 않는다. 그러나 수식에 변수가 들어가 있는 경우 컴파일러가 미리 계산할 수 없어 형변환이 필요하다.
- 비교 연산자 역시 이항 연산자이므로 피연산자의 타입이 다르면 자동 형변환된 후 비교한다. 기본형과 참조형은 서로 형변환이 가능하지 않아 등가비교 연산자로 비교할 수 없다. 
- float과 double의 값을 비교할 때 float을 double로 변환하면 그저 가수 빈자리를 0으로 채울뿐이라 값의 변화가 없다. 따라서 double을 float으로 형변환하면 어느정도 오차는 무시하고 앞에서 몇자리를 잘라 비교할 수 있다.
- 문자열을 비교할 때는 ==가 아닌 equals()를 사용한다. 대소문자 구별없이 비교하고 싶다면 equalsIgnoreCase()를 사용한다.
- 논리 연산자 사용 시 OR 연산의 경우 연산결과가 참일 확률이 높은 피연산자를 연산자의 왼쪽에 놓으면 더 빠른 연산결과를 얻을 수 있다.
- ~는 비트 전환 연산자로 피연산자의 1의 보수를 얻을 수 있다.
- **>>** 연산자의 경우 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 음수인 경우 1로 빈자리를 채운다.
- x **<<** n은 x * 2ⁿ의 결과와 같고 x **>>** n은 x / 2ⁿ의 결과와 같다. 곱셈이나 나눗셈보다 연산속도가 빠르다. 
- 삼항 연산자에서 조건 연산자의 식1과 식2두 피연산자의 타입이 다른 경우 이항 연산자처럼 산술 변환이 일어난다.



## Chapter 04 조건문과 반복문

- 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 **제어문**이라고 한다. 제어문에는 조건문, 반복문이 있다.

### 1. 조건문 - if, switch

- switch문: if문과 달리 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현도 간결하다. break문이 각 case문의 영역을 구분하는데 생략하면 case문 사이의 구분이 없어져 다른 break문을 만나거나 switch 블럭 끝까지 모든 문장을 수행한다.
  - 조건식의 결과값은 반드시 정수여야 한다. 그러나 JDK 1.7부터 문자열 허용
  - case문의 값 역시 정수여야 하고 중복되면 안된다. JDK 1.7부터 문자열 허용
  - case문의 값은 반드시 상수여야한다. 변수, 실수, 문자열은 불가능하다.
  - if와 else if를 사용해 여러번의 조건식을 계산해야할 때와 달리 조건식을 1번만 계산해도 되어 빠르다.

```java
switch (조건식) {
    case 값1 :
        
        break;
    case 값2 :
        
        break;
    default:
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}


// 일부러 break문을 생략하는 경우. 회원제 웹사이트에서 많이 사용될 만한 코드다.
switch (level) {
    case 3 :
        grantDelete();  // 삭제 권한 부여
    case 2 :
        grantWrite();   // 쓰기 권한 부여
    case 1 :
        grantRead();    // 읽기 권한 부여
    default:
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}

// break문 생략하는 경우2
switch (month) {
    case 3 :
    case 4:
    case 5:
        System.out.println("봄");
    case 6 : case 7: case 8:
        System.out.println("여름");
    case 9 : case 10: case 11:
        System.out.println("가을");
    default:
        System.out.println("겨울");
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}
```

- 문자열.charAt(index)로 문자열에 저장된 문자를 가져올 수 있다.



### 2. 반복문 - for, while, do-while

#### 2.1 for문

- 초기화: 보통 변수 하나로 제어하지만 둘 이상이 필요할 경우 콤마를 구분자로 변수를 초기화 한다. 단, 두 변수의 타입이 같아야 한다.
- 증감식: 초기화처럼 콤마를 사용해 두 문장 이상을 하나로 연결해 쓸 수 있다.
- 초기화, 조건식, 증감식은 필요없으면 생략할 수 있고 모두 생략도 가능하다. 조건식이 생략되면 참으로 간주되어 무한 반복이 일어난다. 
- 향상된 for문: JDK 1.5부터 배열, 컬렉션에 저장된 요소에 접근할 떄 기존보다 편리하게 처리할 수 있도록 새로운 문법이 추가되었다.

```java
for (타입 변수명: 배열 또는 컬렉션) {
    // ...
}
```

#### 2.2 while문

- for문과 달리 while문의 조건식은 생략할 수 없다.

#### 2.6 이름 붙은 반복문

- break문은 근접한 단 하나의 반복문만 벗어날 수 있어 여러 개의 반복문이 중첩된 경우에는 완전히 벗어날 수 없다. 이 때는 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다. 

```java
Loop1: for(int i=2; i <= 9; i++) {
    for (int j=1; j <= 9; j++) {
        if (j==5)
            break Loop1;
        //	break;
        //	continue Loop1;
        //	continue;
        
    }
}

// while문에서 사용
outer:
while(true) {
    //
    if (//) {
        break outer;
        }
}
```



## Chapter 05 배열

### 1. 배열(array)

#### 1.1 배열(array)이란?

- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것
- 배열의 변수는 배열을 다룰 때 필요한 참조변수로 값을 저장하는 공간은 아니다.
- 변수와 달리 배열은 각 저장공간이 연속적으로 배치되어 있다.
- 배열의 선언은 배열을 다루기 위한 참조변수의 공간이 만들어지는 것이고 new와 함께 배열 타입과 길이를 지정해주는 **생성**을 해야만 비로소 값을 저장할 수 있는 공간이 만들어진다.
- 유효 범위를 벗어난 값을 index로 사용하는 실수를 컴파일러가 걸러줄 수 없는 이유: 배열 index로 변수를 많이 사용하는데 변수의 값은 실행 시에 대입되므로 컴파일러는 이 값의 범위를 확인할 수 없다.
- **길이가 0인 배열도 생성할 수 있다.**
- 배열은 한번 생성하면 길이를 변경할 수 없기 때문에 배열이름.length는 상수다.
- 배열 생성과 동시에 자신 타입에 따른 기본값으로 초기화되지만 원하는 요소로 초기화할 수도 있다. 

```java
// new int[]는 생략가능하다. 하지만 배열의 선언과 생성을 따로 하는 경우에는 new int[]를 생략할 수 없다.
int[] score = new int[]{50, 60, 70, 80, 90};

// {} 안에 아무것도 넣지 않으면 길이가 0인 배열이 생성된다. 셋 다 길이가 0인 배열이다.
int[] score = new int[0];
int[] score = new int[]{};
int[] score = {}:
```

- 배열 안의 요소를 확인하기 위해 for문을 사용하는 대신 Arrays.toString(배열이름) 메서드를 사용할 수 있다.
- 배열 변수를 바로 출력하면 타입@주소 형식으로 출력되지만 **char배열은 각 요소가 구분자 없이 그대로 출력된다.**
- 배열을 복사하기 위해서 기존 배열의 2배 길인 배열 생성 -> 기존 배열의 값을 새로운 배열에 저장 -> 기존 배열이 새로운 배열을 가리키게 해야한다.
  - 기존 배열과 새로운 배열은 이름만 다를뿐 동일한 배열이다.
  - 배열은 참조변수를 통해서만 접근할 수 있기 때문에 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없다. 이렇게 쓸모없게 된 배열은 JVM의 가비지 컬렉터에 의해 자동적으로 메모리에서 제거된다.
  - for문 대신 값을 하나씩 다시 저장하지 않고 System클래스의 arraycopy()를 사용하면 간단하고 빠르게 복사할 수 있다. arraycopy()는 지정된 범위 값들을 한 번에 통째로 복사한다. 각 요소들이 연속적으로 저장되어 있다는 특성 덕분에 가능하다.
  - System.arraycopy(기존배열이름, 기존배열 복사 시작 위치, 새 배열 이름, 새 배열 복사 시작 위치, 복사할 요소 수)



### 2. String 배열

- String 배열 생성시 참조형 변수 기본값은 null이므로 각 요소는 null로 초기화된다. 또한 참조형 배열의 경우에는 배열에 저장되는 것은 객체의 주소다. 참조형 배열을 객체 배열이라고도 한다.
- String 클래스는 char 배열에 기능(메서드)을 추가한 것이다. 
- 객체지향 기념이 나오기 전의 언어는 데이터와 기능을 따로 두었으나 객체지향언어에서는 데이터와 그와 관련된 기능을 하나의 클래스에 묶어서 다룰 수 있게 한다.
- char배여로가 String클래스의 중요한 차이는 String객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다는 것이다. 문자열을 변경하는 것처럼 보이지만 새로운 내용의 문자열이 생성되는 것이다.
- String클래스의 주요 메서드
  - charAt(int index): 해당 위치의 문자 반환
  - substring(int from, int to): 해당범위의 문자열 반환(to는 포함되지 않는다.)
  - toCharArray(): 문자열을 문자배열로 변환해서 반환 / 문자배열(char 배열)을 String클래스로 변환하는 메서드는 new String(char배열)을 사용
- Scanner클래스로 값을 입력받는 것 외에 **커맨드라인**을 사용해 프로그램 실행 시 클래스 이름 뒤 공백문자로 구분해 여러 문자열을 전달할 수 있다.
  - 공백문자로 매개변수를 구분하기 때문에 입력될 값에 공백이 있는 경우 큰따옴표로 감싸야한다.
  - 숫자를 입력해도 문자열로 처리된다.
  - 배열 생성하지 않으면 참조변수 args가 null이 되어 사용하는 코드에서 에러가 발생하지만 JVM이 null대신 크기가 0인 배열을 생성해 args에 전달하도록 구현한다.



### 3. 다차원 배열

- 선언 방법은 1차원 배열과 같다. 타입[] 변수이름[]으로 써도 2차원 배열로 선언이 된다.
- 1차원 배열과 마찬가지로 {}를 사용해 생성과 초기화를 동시에 할 수 있다. 

```java
// 행별로 줄바꿈을 하면서 초기화하면 더 이해하기 쉽다.
int[][] data = {
    {1, 2, 3},
    {4, 5, 6}
}
```

- 가변배열: 마지막 차수의 길이를 지정하지 않고 추후 각기 다른 길이 배열을 생성할 수 있다.

```java
int[][] data = new int[3][];
data[0] = new int[3];
data[1] = new int[4];
data[2] = new int[10];
```



## Chapter 06 객체지향 프로그래밍 I

### 1. 객체지향언어

- 객체지향이론: 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다. 실제 사물의 속성과 기능을 분석한 후 데이터(변수)와 함수로 정의
  - 주요 특징: 코드의 재사용성 높음 / 코드 관리 용이 / 신뢰성 높은 프로그래밍(제어자, 메서드를 이용해 데이터를 보호하고 올바른 값 유지. **중복을 제거**해 코드 불일치로 인한 오동작 방지)

### 2. 클래스와 객체

- 클래스: 객체를 정의해놓은 것. 객체의 설계도 또는 툴. 클래스는 객체를 생성하는데 사용하며 객체는 클래스에 정의된 대로 생성된다. 개념이나 논리같은 무형적인 것들도 객체로 간주한다. 하나의 설계도만 잘 만들어두면 제품을 만드는 일은 쉬워진다.
- 클래스로부터 객체를 만드는 과정: 인스턴스화 / 만들어진 객체: 인스턴스
- 객체는 **속성**과 **기능**, 두 종류 구성요소로 이루어진다. 객체는 다수의 속성과 다수의 기능을 가진다. 그리고 그 객체가 가진 속성, 기능을 객체의 **멤버**라고 한다. 속성보다는 **멤버변수**, 기능보다는 **메서드**라고 표현한다.
- 인스턴스의 생성

```java
Tv t;             // Tv클래스 타입의 참조변수 t선언
t = new Tv();     // Tv 인스턴스 생성 후, 생성된 인스턴스 주소를 t에 저장
```

- 객체 배열: 객체를 생성해서 객체 배열의 각 요소에 저장하는 것을 잊지 말기.

```java
Tv[] tvArr = new Tv[3];
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 또는
TV[] tvArr = { new Tv(), new Tv(), new Tv() };
```

- 데이터 저장형태의 발전과정
  1. 변수: 하나의 데이터를 저장할 수 있는 공간
  2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
  3. 구조체: 서로 관련된 여러 데이터를 종류 관계없이 하나의 집합으로 저장할 수 있는 공간
  4. 클래스: 데이터와 함수의 결합(구조체 + 함수)



### 3. 변수와 메서드

- 변수는 클래스변수, 인스턴스변수, 지역변수 세 가지가 있다. 종류를 결정짓는 것은 **선언된 위치**다. 멤버변수를 제외한 변수는 모두 지역변수고 멤버변수에서 static이 붙은 것은 클래스변수, 붙지 않은 것은 인스턴스변수다.

```java
class Variables
{
    int iv;          // 인스턴스변수
    static int cv;   // 클래스변수
    
    void method() {
        int lv = 0;  // 지역변수
    }
}
```

- 인스턴스 변수: 클래스 영역에 저장되며 클래스 인스턴스를 생성할 때 만들어진다. 인스턴스 변수의 값을 읽거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다. 인스턴스마다 고유한 상태를 유지해야하는 속성이면 인스턴스변수로 선언한다.
- 클래스 변수: 인스턴스 변수 앞에 static을 붙이면 된다. 모든 인스턴스 변수가 공통된 저장공간을 공유한다. 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다는 특징이 있으며 **클래스이름.클래스변수**와 같은 형식으로 사용한다. 클래스가 메모리에 로딩될 때(올라갈 때) 생성되어 프로그램 종료시까지 유지된다. public을 붙이면 같은 프로그램 내 어디서나 접근 가능한 **전역변수**의 성격을 가진다. 인스턴스이름.클래스변수로 접근해 값을 바꿔도 인스턴스끼리 모두 같은 값을 공유하게 되지만 클래스 이름으로 접근하는 것이 좋다.
- 지역변수: 메서드 내에 선언되어 메서드 내에서만 사용가능해 메서드가 종료되면 소멸한다. 

- 메서드: 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것. 내부가 보이지 않는 블랙박스다. 높은 재사용성, 중복된 코드 제거, 프로그램의 구조화라는 장점을 가진다.
  - 선언부와 구현부로 이루어진다. 
  - 선언부에서 매개변수 선언할 값이 너무 많다면 배열이나 참조변수를 사용하면 된다.
  - 메서드를 호출할 때 괄호 안에 지정해준 값들을 **인자(argument)** 또는 **인수**라고 한다. 
  - 같은 클래스 내의 메서드끼리는 참조변수 사용없이 호출 가능하지만 static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.
  - 반환갑의 유무에 관계없이 모든 메서드는 적어도 하나의 return문이 있어야 한다. 다만 반환타입이 void인 경우 return문이 없으면 컴파일러가 메서드의 마지막에 return;을 자동적으로 추가해주어서 오류가 발생하지 않았다.
  - 메서드 구현부 작성할 때 가장 먼저 해야 하는 일은 매개변수 값이 적절한지 확인하는 것이다. 예를 들어 나누기 메서드를 만들 때는 나누는 값이 0이 아닌지 미리 **유효성 검사**가 필요하다. 



#### 3.7 JVM의 메모리 구조

- 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
- 3가지 주요 영역
  - 메서드 영역(method area): 어떤 클래스가 사용되면 해당 클래스의 클래스파일(*.class)을 읽어서 분석해 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 클래스 변수도 이 영역에 함께 생성된다.
  - 힙(heap): 인스턴스가 생성되는 공간. 인스턴스 변수들도 생성된다.
  - 호출스택(call stack): 메서드가 호출되면 작업에 필요한 메모리 공간 제공. 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과를 저장한다. 작업을 마치면 할당됐던 메모리 공간은 반환되어 비워진다. 각 메서드를 위한 메모리상의 작업공간은 서로 구별된다. 처음 호출된 메서드를 위한 작업공간이 호출 스택 맨 밑에 마련되고 수행 중 다른 메서드를 호출하면 바로 위에 두 번째 메서드를 위한 공간이 마련된다. 이 때 첫 번째 메서드는 수행을 멈추고 두 번째 메서드가 수행되기 시작한다. 두 번째 메서드 작업이 끝나면 메모리 공간이 반환되고 다시 첫 번째 메서드를 수행하게 된다. 호출 스택의 가장 상위의 메서드가 현재 실행 중인 메서드이며 나머지는 대기상태에 있는다.
- 객체를 생성하지 않고 메서드를 호출하려면 메서드 앞에 static을 붙여야 한다.
- 기본형 매개변수와 참조형 매개변수: 메서드 호출 시 매개변수로 지정한 값을 메서드 매개변수에 복사해서 넘겨준다. 기본형일 때는 값이 복사되지만 참조형이면 인스턴스 주소가 복사된다. 따라서 참조형일 경우 저장된 곳의 주소를 알 수 있어 값을 읽어 오는 것은 물론 변경하는 것도 가능하다. 
- 반환타입이 참조형이면 메서드가 객체의 주소를 반환한다는 것이다.



#### 3.10 재귀호출(recursive call)

- 값에 의한 호출로 원래 값이 아닌 복사된 값으로 작업하기 때문에 호출된 메서드 관계없이 독립적인 작업수행이 가능하다.
- 재귀호출로 작성하면 다소 비효율적이라도 알아보기 쉬워 논리적 오류가 발생할 가능성도 줄어들고 수정하기 좋다.



#### 3.11 클래스 메서드(static 메서드)와 인스턴스 메서드

- 클래스 변수(static 변수), 인스턴스 변수 모드 멤버변수로 클래스 영역에 선언된 변수다. 
- 변수처럼 메서드 앞에 static이 붙어 있으면 클래스 메서드고 아니면 인스턴스 메서드다.
- 클래스 메서드도 클래스 변수처럼 객체를 생서하지 않고도 클래스이름.메서드이름으로 호출이 가능하다. 반면 인스턴스 메서드는 반드시 객체를 생성해야 호출할 수 있다.
- 클래스는 데이터(변수)와 데이터와 관련된 메서드의 집합이므로 같은 클래스 내의 메서드와 멤버변수는 아주 밀접한 관계가 있다.
- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 해 메서드 작업 수행에 인스턴스 변수가 필요하다. 
- 반면 인스턴스와 관계없는(인스턴스 변수, 인스턴스 메서드 사용하지 않는) 메서드를 클래스 메서드(static 메서드)로 정의한다.

1. 클래스를 설계할 때 멤버변수 중 모든 인스턴스에서 같은 값을 유지하는 변수는 static을 붙여 클래스 변수로 정의한다.
2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다. 클래스가 메모리에 올라갈 때 자동적으로 생성되기 때문이다.
3. 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다. 반면 인스턴스 변수, 메서드는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재하면 static 변수는 이미 메모리에 존재하기 때문이다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않으면 static을 붙인다. 메서드 호출 시간이 짧아져 성능이 향상된다. 인스턴스 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요해 시간이 더 걸린다.



### 4. 오버로딩(overloading)

- 한 클래스 내에 사용하려는 이름과 같은 이름을 가진 메서드가 있어도 **매개변수의 개수** 또는 **타입**이 다르면 같은 이름으로 정의할 수 있다. 이를 오버로딩이라고 한다. 매개변수에 의하서만 구분되며 반환 타입은 오버로딩 구현에 영향을 주지 못한다.
- 기존에는 메서드 매개변수 개수가 고정적이었으나 JDK 1.5부터 동적으로 지정해 줄 수 있게 되었다. 이 기능을 **가변인자(variable arguments)**라고 한다. **타입... 변수명**같은 형식으로 선언한다. 가변인자는 매개변수 중 가장 마지막에 선언하지 않으면 컴파일 에러가 발생한다. 인자 없어도 되고 해당 타입의 배열을 넘겨주는 것도 가능하다. 가변인자는 **내부적으로 배열을 이용**하기 때문이다. 하지만 매개변수 타입을 배열로 지정해줄 경우 인자가 없으면 에러가 발생한다. 따라서 null이라도 넘겨야한다. 주의할 점은 가변인자를 선언 메서드를 오버로딩하면 구별되지 못하는 경우가 발생하므로 하지 오버로딩하지 않는 것이 좋다.



### 5. 생성자(Constructor)

- 인스턴스가 생성될 때 호출되는 **인스턴스 초기화 메서드**(인스턴스 변수들을 초기화). 메서드처럼 클래스 내에 선언되지만 리턴값이 없다는 점이 다르다. 생성자의 조건은 이름이 클래스 이름과 같아야 하며 리턴값이 없다는 것이다. 생성자 역시 오버로딩이 가능하다. 인스턴스 생성은 연산자 **new**로 하는 것이지 생성자가 인스턴스를 생성하는게 아니다.  
- 클래스에 생성자가 없으면 컴파일러가 매개변수, 내용이 없는 기본 생성자를 제공한다.
- 생성자 간 호출: 생성자 이름 대신 **this**사용, 반드시 **첫 줄**에서만 호출 가능. 생성자 내에서 초기화 작업도중에 다른 생성자를 호출하게 되면 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것 이므로 이전 작업이 무의미해질 수 있기 때문이다. 

```java
class Car{
    String color;
    String gearType;
    int door;
    
    Car() {
        this("white", "auto", 4);
    }
    
    // 생성자 매개변수 이름이 인스턴스 변수 이름과 같아 구별이 안된다. 이런 경우 인스턴스 변수 앞에 this를 사용한다. 생성자 매개변수로 인스턴스변수들의 초기값을 받는 경우가 많아 일치할 때가 많다.
    // this는 참조변수로 인스턴스 자신을 가리키고 이를 사용해 인스턴스변수에 접근할 수 있다. 인스턴스멤버만 this를 사용할 수 있고 static 메서드에서는 불가능하다. 
    // 생성자 포함 모든 인스턴스 메서드는 자신이 관련된 인스턴스를 가리키는 참조변수 this가 지역변수로 숨겨진채 존재한다.
    Car(String color, String gearType, int door) {
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}
```

- this: 인스턴스 자신을 가리는 참조변수로 인스턴스 주소가 저장되어 있다.
- this(), this(매개변수): 생성자. 같은 클래스 다른 생성자를 호출할 때 사용
- 생성자를 이용해 인스턴스를 복사하기 위해 인스턴스를 매개변수로 받는 생성자를 만들 수 있다. 또는 Object 클래스의 clone메서드를 이용할 수도 있다.



### 6. 변수의 초기화

- 변수를 선언하고 처음으로 값을 저장하는 것. 선언과 동시에 적절한 값으로 초기화하는 게 바람직하다.
- 멤버변수는 초기화하지 않아도 자료형에 맞는 기본값으로 초기화되므로 초기화하지 않고 사용해도 되지만 지역변수는 사용하기 전에 반드시 초기화해야 한다. 
- 멤버변수의 초기화 방법: 명시적 초기화, 생성자, 초기화 블럭
  - 명시적 초기화: 선언과 동시에 초기화
  - 초기화 블럭: 클래스 변수의 복잡한 초기화에 사용하는 **클래스 초기화 블럭**과 인스턴스변수의 복잡한 초기화에 사용되는 **인스턴스 초기화 블럭**이 있다.  인스턴스 초기화 블럭은 단순히 클래스 내에 블럭을 만들고 그 안에 코드를 작성하며 클래스 초기화 블럭은 인스턴스 초기화 블럭 안에 static을 덧붙이면 된다. 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다. 인스턴스 변수 초기화는 주로 생성자를 사용하며 **모든 생성자에서 공통적으로 수행돼야 하는 코드**를 넣을 때 인스턴스 초기화 블럭을 이용한다.

```java
class Car{
    String color;
    String gearType;
    int serialNo;
    
    // 인스턴스 초기화 블럭. 중복을 제거해 코드의 신뢰성을 높이고 오류 발생 가능성을 줄인다. 객체 지향 프로그래밍의 목표
    {
        count++;
        serialNo = count;
    }
    
    Car() {
        color = white;
        gearType = "Auto";
    }
    
    Car(String color, String gearType) {
        this.color = color;
        this.gearType = gearType;
    }
}
```

- 클래스변수 초기화순서: 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
- 인스턴스변수 초기화순서: 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자

