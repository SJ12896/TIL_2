## Java의 정석

### Chapter01 자바를 시작하기 전에

#### 1.1 자바란?

- 썬 마이크로시스템즈에서 개발한 객체지향 프로그래밍 언어
- 운영체제에 독립적이어서 종류에 관계없이 실행가능해 프로그램을 전혀 변경하지 않고도 실행이 가능
- 풍부한 클래스 라이브러리(Java API)를 통해 프로그래밍에 필요한 요소들을 기본적으로 제공



#### 1.3 자바언어의 특징

1. 운영체제에 독립적: 자바 프로그램이 운영체제, 하드웨어가 아닌 에뮬레이터 `자바가상머신(JVM)`하고만 통신해 JVM이 받은 명령을 해당 운영체제가 이해할 수 있도록 변환해 전달한다. JAVA로 작성한 프로그램과 달리 JVM은 운영체제에 종속적이어서 서로 다른 버전의 JVM이 제공되고 있다. Write once, Run anywhere
2. 객체지향언어: 상속, 캡슐화, 다형성이 잘 적용되었다. 재사용성 & 유지보수의 용이성
3. 비교적 배우기 쉬움: C++과 스몰톡의 장점을 취하고 복잡한 부분은 제거. 많은 장점에도 불구하고 배우기 어려웠던 객체지향 프로그래밍의 저변 확대에 큰 기여를 했다.
4. 자동 메모리 관리(Garbage Collection): 자바 프로그램이 실행되면 가비지 컬렉터가 자동적으로 메모리를 관리해줘 프로그래머가 수동적으로 사용하지 않는 메모리를 체크하고 반환하는 관리가 필요 없다.
5. 네트워크와 분산처리 지원: 라이브러리를 통해 비교적 짧은 시간에 네트워크 관련 프로그램 쉽게 개발
6. 멀티쓰레드 지원: 일반적으로 운영체제에 따라 구현방법과 처리방식이 다르지만 자바에서 개발되는 멀티쓰레드 프로그램은 시스템과 관계없이 구현 가능하며 라이브러리가 제공되어 쉽다. 여러 쓰레드에 대한 스케줄링을 자바 인터프리터가 담당한다.
7. 동적 로딩 지원(Dynamic Loading): 보통 자바 애플리케이션은 여러 클래스로 구성되는데 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 로딩할 수 있다. 또 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 되고 비교적 적은 작업으로 변경사항을 처리할 수 있다.



#### 1.4 JVM(Java Virtual Machine)

- 자바를 실행하기 위한 가상 컴퓨터(소프트웨어로 구현된 컴퓨터)
- 가상 기계: 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어
- 일반 애플리케이션 코드는 OS만 거치고 하드웨어로 전달되는데 자바 애플리케이션은 JVM을 거쳐야하고 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시 해석되기 때문에 속도가 느리다는 단점이 있었다.  그러나 바이트코드(컴파일된 자바코드)를 하드웨어 기계어로 바로 변환하는 JIT 컴파일러와 Hotspot같은 신기술 도입으로 JVM 기능이 향상되어 속도문제가 개선되었다.



#### 2. 자바개발환경 구축하기

#### 2.1 자바 개발도구(JDK) 설치하기

- 자바 프로그래밍을 위해서 먼저 JDK(Java Development Kit)를 설치해야 한다. JDK를 설치하면 JVM, 자바클래스 라이브러리와 개발에 필요한 프로그램들이 설치된다. 
- JDK설치 후 설치 디렉토리 bin을 path에 추가해야한다. 이 디렉토리에 자바로 프로그램을 개발하는데 필요한 실행파일들이 있다. path는 OS가 파일 위치를 파악하는데 사용하는 경로로 path에 디렉토리를 등록하면 해당 디렉토리에 포함된 파일을 경로없이 이름만으로 사용할 수 있게 된다. 
- JDK bin 디렉토리의 주요 실행파일들: javac.exe(자바 컴파일러. 소스코드를 바이트코드로 컴파일) / java.exe(자바 인터프리터. 컴파일러가 생성한 바이트코드 해석하고 실행) / javap.exe(역어셈블러. 컴파일된 클래스파일을 원래 소스로 변환) / javadoc.exe(자동문서생성기. 소스파일의 주석을 이용해 API문서같은 형식 문서를 자동 생성) / jar.exe(압축프로그램. 클래스파일과 프로그램 실행 관련 파일을 하나의 jar파일로 압축하거나 압축해제한다.)
- JRE: 자바실행환경(Java Runtime Enviornment). 자바로 작성된 응용프로그램이 실행되기 위한 최소환경
- JDK = JRE + 개발에 필요한 실행파일
- JRE = JVM + 클래스 라이브러리(Java API)



#### 2.2 Java API문서 설치하기



### 3. 자바로 프로그램작성하기

#### 3.1 Hello.java

- 자바에서 모든 코드는 반드시 클래스 안에 존재해야 하고 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스를 구성하게 된다. 
- 소스파일의 이름은 public class의 이름과 일치해야 한다. 소스파일 내에 public class가 없다면 소스파일 이름은 소스파일 내의 어떤 클래스 이름으로 해도 상관없다. 
- 소스파일(.java)과 달리 클래스파일(.class)은 클래스마다 하나씩 만들어진다.



#### 3.2 자주 발생하는 에러와 해결방법

#### 3.3 자바 프로그램 실행과정

1. 프로그램 실행에 필요한 클래스를 로드한다.
2. 클래스 파일을 검사한다.
3. 지정된 클래스에서 main메서드를 호출한다.



### Chapter02 변수

### 1. 변수(variable)

- 단 하나의 값을 저장할 수 있는 메모리상의 공간
- 메모리는 여러 프로그램이 공유하는 자원으로 다른 프로그램에 의해 저장된 알 수 없는 값이 남아있을 수 있어 사용 전 **초기화**(사용하기 전 처음으로 값 저장) 해야한다.
- 변수 사용가능 특수문자: _ $
- 필수는 아니지만 권장하는 규칙: 클래스 이름 첫 글자는 항상 대문자 / 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 / 상수 이름은 모두 대문자며 여러 단어인 경우 _로 구분



### 2. 변수의 타입

- 자료형은 크게 기본형 / 참조형으로 나뉜다.
  - 기본형: 실제 값 저장 / C언어와 달리 참조형 변수간 연산 불가능, 실제 연산에 사용되는건 boolean을 제외한 기본형이므로 서로 변환 가능 / 논리형(boolean), 문자형(char), 정수형(byte, short, **int**, long), 실수형(float, **double**)
  - 참조형: 어떤 값이 저장된 주소 / 기본형 제외한 나머지 / JVM이 32 bit면 4 byte, 64 bit면 8 byte
- 참조형 변수를 선언할 때 변수 타입으로 클래스 이름을 사용한다. 클래스 이름은 참조변수 타입이 되므로 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.
- int는 대략 10자리수(약 20억)의 값을 저장할 수 있다.
- 실수형은 큰 값을 저장할 수 있지만 오차가 발생할 수 있다. float은 정밀도가 7자리로 10진수 7자리의 수를 오차없이 저장, dobule은 15자리

#### 2.2 상수와 리터럴

- JDK 1.6부터 상수를 선언과 동시에 초기화 하지 않아도 된다. 하지만 선언과 동시에 초기화하는 편이 좋다. 상수를 사용하면 다른 값을 계산할 때 여러 곳 수정할 필요 없고 이해와 수정을 돕는다.
- 리터럴: 그 자체로 값을 의미하는 것

- 접미사: L(정수 long 타입일 경우) / f, d(double이 기본이라 생략 가능) / 대소문자 상관X
- 접두사:  0을 붙이면 8진수, 0x는 16진수, 0b는 2진수로 저장 / 대소문자 상관X
- JDK 1.7부터 정수형 리터럴 중간에 구분자_를 넣어 큰 숫자를 편하게 읽을 수 있게 했다.
- 리터럴에 소수점이나 십의 제곱을 나타내는 e 또는 접미사 f, d등이 있으면 실수형으로 간주, 드물지만 p도(2의 제곱 의미하며 16진 지수형태 표현)
- 타입의 불일치: 저장범위가 넓은 타입에 좁은 값 저장은 허용
- 문자 리터럴: 작은 따옴표로 문자 하나 감싼 것으로 반드시 ''안에 하나의 문자 필요



#### 2.3 형식화된 출력 - printf()

- 지시자를 이용해 변수 값을 여러 형식으로 변환해 출력한다. 지시자 개수 제한은 없으며 줄바꿈을 하려면 %n을 넣어준다.(\n도 가능하지만 OS마다 다를 수 있어 %n 권장)
- %b: boolean / %d: 10진(decimal) / %o: 8진(octal) / %x: 16진(hexa) / %f: 부동소수점(floating-point) / %e: 지수(exponent) / %c: 문자(character) / %s: 문자열(string)
- 출력될 값이 차지할 공간을 숫자로 지정 가능
  - %와 지시자 사이에 숫자가 공간 크기
  - 크기 앞에 -를 붙이면 오른쪽부터 공간 차지
  - 숫자나 문자를 써넣으면 해당 글자가 남는 공간을 차지
  - .숫자를 써넣으면 왼쪽에서부터 숫자만큼만 출력
  - %f는 기본적으로 6자리만 출력하므로 7번째에서 반올림된다. 따라서 숫자.숫자를 사용해 소수 자리수를 지정가능한다. 모자르면 0으로 채워진다.
- %x(%X), %o에 #을 사용하면 0x, 0이 붙는다.
- 10진수 -> 2진수로 출력하는 지시자는 없기 때문에 문자열 지시자를 사용후 Integer.toBinaryString(binNum)을 이용한다.
- char타입을 %d로 출력할 수 없다. 형변환 필요



#### 2.4 화면에서 입력받기

- 연속적으로 값을 입력받을 때 nextLine()으로 입력받은 후 변환하는 것을 추천한다.



### 3. 진법

#### 3.2 비트와 바이트

- 비트: 한 자리의 2진수 / 1비트는 컴퓨터가 값을 저장할 수 있는 최소단위
- 바이트: 1 비트는 너무 작아 1 비트를 8개 묶어 바이트로 정의하고 데이터 기본 단위로 사용
- 워드: CPU가 한 번에 처리할 수 있는 데이터의 크기. CPU 성능에 따라 달라져 32비트에선 32비트고 64비트에선 64비트가 된다.

#### 3.3 진법변환

- 2진수 -> 8진수: 2진수를 뒤에서부터 3자리씩 끊어 해당하는 8진수로 바꾼다. 
- 10진 소수점수 -> 2진 소수점수: 10진 소수점수에 2를 곱해서 나온 결과에서 소수부만 가져다 계속 2를 곱한다. 소수부가 0이 될때까지 반복한다. 그리고 곱한 결과 값에서 정수부만을 위에서 아래대로 적고 0.을 붙이면 된다.



#### 3.6 음수의 2진 표현 - 2의 보수법

- n비트의 2진수로 표현할 수 있는 값의 개수는 2ⁿ개로 모두 부호없는 정수다. 
- 음수를 표현하는 법1: 1로 시작하는 2진수를 음수표현에 사용하고 순차적으로 -0부터 시작한다. 하지만 두 수를 더했을 때 2진수로 0이 되지않고 2개의 0이 존재하는 단점이 있다. 또 2진수가 증가할 때 10진 음수는 감소한다.
- 2의 보수법
  - 절대값이 같은 양수 음수를 더했을 때 2진수로도 0의 결과를 얻게되고 2진수가 증가할 때 10진 음수도 증가한다. 
  - n의 보수: 더했을 때 n이 되는 수
  - 2진수로 10은 **자리올림이 발생하고 0이 되는 수를 뜻한다.** (이 부분 약간 애매. 더 찾아볼 것)
  - 음수를 2진수로 표현하기 위해서는 절대값의 2진수를 구한 후 2의 보수를 구하면 된다.
  - 2의 보수 = 1의 보수 + 1 / 2진수에서 1의 보수를 더하면 모든 자리가 1이 된다. 여기서 양변에 1을 더하면 우변은 0이 되는데 올림이 발생하지만 4비트를 넘어 저장할 공간이 없어 버려진다. 



### 4. 기본형(primitive type)

#### 4.2 문자형 - char

- char에는 문자가 아닌 문자의 유니코드가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장한다. 그래서 문자의 유니코드를 직접 저장해도 동일한 결과를 가진다.
- tab은 \t, backspace는 \b 등 특수문자를 저장할 수 있다.
- char는 2byte(=16bit)로 모두 2¹⁶개의 값을 표현할 수 있고 0포함 모든 양수여야 한다. 반면 short는 같은 크기지만 절반을 음수 표현에 사용한다. char에 A, short에 65를 저장하면 둘 다 2진수로 같은 값이 저장되지만 println()으로 출력할 때 변수 타입이 정수형이면 변수에 저장된 값을 10진수로 해석해 출력하고 문자형이면 저장된 숫자에 해당하는 유니코드 문자를 출력한다.
- 문자 -> 코드: 인코딩, A -> 65
- 코드 -> 문자: 디코딩, 65 -> A
- 유니코드: 전 세계 모든 문자를 하나의 통일된 문자집합으로 표현하고자 노력한 결과. 유니코드에 포함시키고자 하는 문자들의 집합을 정의한 것을 유니코드 문자 셋이라고 한다. 그리고 이 문자셋에 번호를 붙인 것이 유니코드 인코딩이다. UTF-16은 자바에서 사용하며 모든 문자를 2byte 고정 크기로 표현한다. UTF-8은 1~4 byte 가변크기로 표현한다. UTF-16은 1byte로 표현가능한 영어와 숫자도 2byte로 표현되어 문서의 크기가 커지는 단점이 있다. 인터넷에서 문서 크기가 작을수록 전송속도에 좋기 때문에 UTF-8로 작성된 웹문서가 빠르게 늘고 있다.

#### 4.3 정수형 -byte, short, int, long

- 어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다. 
  - 정수형의 저장: 부호비트 + (n-1)bit 
  - n비트로 표현할 수 있는 정수의 개수: 2ⁿ개(최대값은 절반에서 1을 빼야한다. 0도 포함되기 때문)
- 오버플로우: 연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것. 부호없는 정수는 2진수로 0000이 될 때 오버플로우가 발생하고 부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생.
  - 최소값에서 1을 빼면 최대값이 되고 최대값에서 1을 더하면 최소값이 된다.

#### 4.4 실수형 - float, double

- 실수형은 얼마나 큰 값은 표현할 수 있는가 뿐만 아니라 얼마나 0에 가깝게 표현할 수 있는가도 중요하다.
- 실수형에서 오버플로우가 발생하면 변수 값은 무한대가 된다. 그리고 정수형에 없는 언더플로우가 있는데 실수형으로 표현할 수 없는 아주 작은 값, 양의 최소값보다 작은 값이 되는 경우를 말한다.
- 정수형은 부호와 값으로 이루어져있지만 실수형은 부호(S), 지수(E), 가수(M) 세부분으로 이루어져있다. 2의 제곱을 곱한 형태로 저장(+-M * 2의 E승)하기 때문에 큰 범위를 저장하는 게 가능하다. 
- 그러나 정수형과 달리 오차가 발생할 수 있다는 단점이 있다. 실수형은 표현할 수 있는 값의 범위 뿐 아니라 정밀도가 중요한 요소다. 
- 부호: 0이면 양수, 1이면 음수. 정수형과 달리 2의 보수법을 사용하지 않아 양의 실수 -> 음의 실수 하려면 부호비트만 0에서 1로 변경 / 1
- 지수: 부호있는 정수. / float은 8, double은 11
- 가수: 실제값을 저장하는 부분. / float은 23, double은 52 / float 2진수 23자리로 7자리 10진수를 저장할 수 있는데 이게 바로 float의 정밀도가 된다. 



### 5. 형변환

- float을 int로 변환할 때 소수점 이하의 값은 반올림이 아닌 버림 처리된다.
- 실수형간의 형변환
  - float -> double: 지수는 float의 기저인 127을 빼고 double의 기저인 1023을 더해서 변환
  - double -> float: 지수는 double의 기저인 1023을 빼고 float의 기저인 127을 더함. 가수는 double의 가수 52자리 중 23자리만 저장되고 나머지 버림. 그런데 가수 24번째 자리에서 반올림 발생할 수 있다. 24자리가 1이면 23번째 자리가 1이 증가한다. / 또한 float의 범위를 넘는 값을 float으로 형변환하면 플러스마이너스 무한대 또는 플러스마이너스 0을 얻게된다.
- 정수형 -> 실수형: 2진수로 변환 후 정규화를 거쳐 실수 저장형식으로 저장된다. 다만 int는 최대 10자리의 정밀도를 요구하는데 float은 7자리만을 제공하므로 정밀도 차이에 의한 오차가 발생할 수 있다. 
- 실수형 -> 정수형: 소수점 이하 값은 버려진다. 형변환 시 반올림이 발생하지 않는다.
- 자동 형변환: 변수가 저장가능한 값 범위보다 큰 값을 저장하려는 경우 형변환을 생략하면 에러가 발생하지만 명시해줬을 경우 의도적인 것으로 간주하고 에러를 발생시키지 않는다. 서로 다른 두 타입의 덧셈에서는 표현범위가 더 넓은 타입으로 형변환해 일치시킨 다음 연산을 수행한다. 



## Chapter 03 연산자

- 쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다.
- 비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮다. ex) data & 0xFF == 0 에서 ==먼저 실행
- 보통 왼쪽에서 오른쪽 순서로 연산을 수행하지만 단항 연산자와 대입 연산자만 오른쪽에서 왼쪽 순서로 수행한다. 
- 우선순위: 산술 > 비교 > 논리 > 대입 / 단항 > 이항 > 삼항
- 산술 변환: 피연산자의 타입 일치를 위해 자동으로 형변환되는 것. 보통 둘 중 큰 타입으로 맞춰지지만 피연산자의 타입이 int보다 작다면 int로 변환된다.(byte + short같은 경우) 따라서 byte + byte 결과를 byte 타입의 변수에 저장하려면 형변환이 필요하다.
- 연산결과의 타입은 피연산자의 타입과 일치한다. int와 int를 나눈 결과는 int다. 
- int a, b가 있을 때 long c = a * b이고 결과 값이 int의 범위를 넘어서는 값이라면 결과 변수가 long이라 제대로 계산된 값이 나올 것 같지만 a * b의 값이 이미 int의 값이므로 잘못된 값이 나온다. 따라서 a 또는 b를 long으로 형변환해 계산해야 한다. 
- char c2 = 'a'; c2 = c2 + 1;이란 코드를 작성하면 c2가 계산과정에서 자동으로 int로 형변환되었고 그 결과를 char에 담으려 해서 오류가 발생한다. 하지만 char c2 = 'a' + 1;은 오류가 발생하지 않는데 리터럴 간의 연산이기 때문이다. **상수 또는 리터럴 간의 실행과정동안 변하는 값이 아니기 때문에 컴파일 시 컴파일러가 계산해서 그 결과로 대체**한다. 컴파일러가 미리 덧셈연산을 수행하므로 실행 시에는 연산이 수행되지 않는다. 그러나 수식에 변수가 들어가 있는 경우 컴파일러가 미리 계산할 수 없어 형변환이 필요하다.
- 비교 연산자 역시 이항 연산자이므로 피연산자의 타입이 다르면 자동 형변환된 후 비교한다. 기본형과 참조형은 서로 형변환이 가능하지 않아 등가비교 연산자로 비교할 수 없다. 
- float과 double의 값을 비교할 때 float을 double로 변환하면 그저 가수 빈자리를 0으로 채울뿐이라 값의 변화가 없다. 따라서 double을 float으로 형변환하면 어느정도 오차는 무시하고 앞에서 몇자리를 잘라 비교할 수 있다.
- 문자열을 비교할 때는 ==가 아닌 equals()를 사용한다. 대소문자 구별없이 비교하고 싶다면 equalsIgnoreCase()를 사용한다.
- 논리 연산자 사용 시 OR 연산의 경우 연산결과가 참일 확률이 높은 피연산자를 연산자의 왼쪽에 놓으면 더 빠른 연산결과를 얻을 수 있다.
- ~는 비트 전환 연산자로 피연산자의 1의 보수를 얻을 수 있다.
- **>>** 연산자의 경우 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 음수인 경우 1로 빈자리를 채운다.
- x **<<** n은 x * 2ⁿ의 결과와 같고 x **>>** n은 x / 2ⁿ의 결과와 같다. 곱셈이나 나눗셈보다 연산속도가 빠르다. 
- 삼항 연산자에서 조건 연산자의 식1과 식2두 피연산자의 타입이 다른 경우 이항 연산자처럼 산술 변환이 일어난다.



## Chapter 04 조건문과 반복문

- 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 **제어문**이라고 한다. 제어문에는 조건문, 반복문이 있다.

### 1. 조건문 - if, switch

- switch문: if문과 달리 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현도 간결하다. break문이 각 case문의 영역을 구분하는데 생략하면 case문 사이의 구분이 없어져 다른 break문을 만나거나 switch 블럭 끝까지 모든 문장을 수행한다.
  - 조건식의 결과값은 반드시 정수여야 한다. 그러나 JDK 1.7부터 문자열 허용
  - case문의 값 역시 정수여야 하고 중복되면 안된다. JDK 1.7부터 문자열 허용
  - case문의 값은 반드시 상수여야한다. 변수, 실수, 문자열은 불가능하다.
  - if와 else if를 사용해 여러번의 조건식을 계산해야할 때와 달리 조건식을 1번만 계산해도 되어 빠르다.

```java
switch (조건식) {
    case 값1 :
        
        break;
    case 값2 :
        
        break;
    default:
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}


// 일부러 break문을 생략하는 경우. 회원제 웹사이트에서 많이 사용될 만한 코드다.
switch (level) {
    case 3 :
        grantDelete();  // 삭제 권한 부여
    case 2 :
        grantWrite();   // 쓰기 권한 부여
    case 1 :
        grantRead();    // 읽기 권한 부여
    default:
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}

// break문 생략하는 경우2
switch (month) {
    case 3 :
    case 4:
    case 5:
        System.out.println("봄");
    case 6 : case 7: case 8:
        System.out.println("여름");
    case 9 : case 10: case 11:
        System.out.println("가을");
    default:
        System.out.println("겨울");
        // 조건식 결과와 일치하는 case문이 없을 때 수행될 문장들
}
```

- 문자열.charAt(index)로 문자열에 저장된 문자를 가져올 수 있다.



### 2. 반복문 - for, while, do-while

#### 2.1 for문

- 초기화: 보통 변수 하나로 제어하지만 둘 이상이 필요할 경우 콤마를 구분자로 변수를 초기화 한다. 단, 두 변수의 타입이 같아야 한다.
- 증감식: 초기화처럼 콤마를 사용해 두 문장 이상을 하나로 연결해 쓸 수 있다.
- 초기화, 조건식, 증감식은 필요없으면 생략할 수 있고 모두 생략도 가능하다. 조건식이 생략되면 참으로 간주되어 무한 반복이 일어난다. 
- 향상된 for문: JDK 1.5부터 배열, 컬렉션에 저장된 요소에 접근할 떄 기존보다 편리하게 처리할 수 있도록 새로운 문법이 추가되었다.

```java
for (타입 변수명: 배열 또는 컬렉션) {
    // ...
}
```

